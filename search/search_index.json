{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PassiveAutoDesign Python Script for Fast Design of RF-Passive Components. This script is in an early stage of development. Tested on Windows and Linux. Getting started The library required are scikit-rf, numpy, scipy, yaml and matplotlib (for plotting results). The required versions can be find in requirements.txt . Install the library using pip install passive-auto-design A demo is given here and the documentation can be found here Package Structure The Package is composed of five modules: The substrate.py file which describes the substrate used (or Back End Of Line). The components directory which contains RF-components to be implemented in a susbtrate (Waveguides, Transformers, Coupler...). It also enables rough geometry design/estimation from given rf specifications. The special.py file which contains physical constants and special functions (dB, NmtodBcm, ...) The space_mapping.py file which help deploy space mapping algorithm. The unit.py file which contains fonction to hlp formatting number to string.","title":"Home"},{"location":"#passiveautodesign","text":"Python Script for Fast Design of RF-Passive Components. This script is in an early stage of development. Tested on Windows and Linux.","title":"PassiveAutoDesign"},{"location":"#getting-started","text":"The library required are scikit-rf, numpy, scipy, yaml and matplotlib (for plotting results). The required versions can be find in requirements.txt . Install the library using pip install passive-auto-design A demo is given here and the documentation can be found here","title":"Getting started"},{"location":"#package-structure","text":"The Package is composed of five modules: The substrate.py file which describes the substrate used (or Back End Of Line). The components directory which contains RF-components to be implemented in a susbtrate (Waveguides, Transformers, Coupler...). It also enables rough geometry design/estimation from given rf specifications. The special.py file which contains physical constants and special functions (dB, NmtodBcm, ...) The space_mapping.py file which help deploy space mapping algorithm. The unit.py file which contains fonction to hlp formatting number to string.","title":"Package Structure"},{"location":"spacemap/","text":"Implementation of an aggressive space mapping algorithm for RF-design cost_calc ( perf_list , goal_list , weight_list = None ) return the normalize standard deviation between the perf_list and the goal_list Parameters: Name Type Description Default perf_list tuple of float list of the performances achieved. required goal_list tuple of float list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval. required weight_list tuple of float weightning of the goals. If set to None, all the weight are set to one. None Returns: Type Description float cost value Source code in passive_auto_design\\space_mapping.py @functools . lru_cache () def cost_calc ( perf_list , goal_list , weight_list = None ): \"\"\" return the normalize standard deviation between the perf_list and the goal_list Parameters ---------- perf_list : tuple of float list of the performances achieved. goal_list : tuple of float list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval. weight_list : tuple of float, optional weightning of the goals. If set to None, all the weight are set to one. Returns ------- cost : float cost value \"\"\" if weight_list is None : weight_list = [ 1 ] * len ( goal_list ) cost = 0 for itern , goal in enumerate ( goal_list ): perf = perf_list [ itern ] goal = goal_list [ itern ] if isinstance ( goal , tuple ): err_min = max (( perf - goal [ 0 ]) / ( goal [ 0 ] if goal [ 0 ] != 0 else 1 ), 0 ) err_max = max (( goal [ 1 ] - perf ) / ( goal [ 1 ] if goal [ 1 ] != 0 else 1 ), 0 ) err = err_min + err_max else : err = ( perf - goal ) / ( goal if goal != 0 else 1 ) cost += weight_list [ itern ] * err ** 2 return cost space_map ( coarse_model , dim0 , fine_model , par0 , goal , maxiter = 5 ) Optimization function for space mapping algorithm. Parameters: Name Type Description Default coarse_model fun function evaluating the coarse model goals for a set of dimensions (dim) and parameters (par) required dim0 dict initial dimensions of the component required fine_model fun function evaluating the fine model goals for a set of dimensions (dim) required par0 dict initial parameters of the component coarse model required goal dict set of goal targeted by the algorithm required maxiter int maximal number of iteration. The default is 5. 5 Returns: Type Description dict final dimension of the component. Source code in passive_auto_design\\space_mapping.py def space_map ( coarse_model , dim0 , fine_model , par0 , goal , maxiter = 5 ): \"\"\" Optimization function for space mapping algorithm. Parameters ---------- coarse_model : fun function evaluating the coarse model goals for a set of dimensions (dim) and parameters (par) dim0 : dict initial dimensions of the component fine_model : fun function evaluating the fine model goals for a set of dimensions (dim) par0 : dict initial parameters of the component coarse model goal : dict set of goal targeted by the algorithm maxiter : int, optional maximal number of iteration. The default is 5. Returns ------- dim : dict final dimension of the component. par : dict final parameters of the component model. fine_mod : dict achieved goal. \"\"\" dim = dim0 par = par0 achieved_goal = goal for i in range ( maxiter ): # evaluate exact value using fine model achieved_goal = fine_model ( dim ) # alter coarse model parameters to better match fine model results res = minimize ( __refresh_coarse , __totuple ( par ), method = \"L-BFGS-B\" , args = ( par0 . keys (), dim , coarse_model , achieved_goal ), ) par = __todict ( par0 . keys (), res . x ) # find best solution according to coarse model res = minimize ( __cost_coarse , __totuple ( dim ), method = \"Powell\" , args = ( dim0 . keys (), par , coarse_model , goal ), ) dim = __todict ( dim0 . keys (), res . x ) return dim , par , achieved_goal","title":"Space Mapping"},{"location":"spacemap/#passive_auto_design.space_mapping.cost_calc","text":"return the normalize standard deviation between the perf_list and the goal_list Parameters: Name Type Description Default perf_list tuple of float list of the performances achieved. required goal_list tuple of float list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval. required weight_list tuple of float weightning of the goals. If set to None, all the weight are set to one. None Returns: Type Description float cost value Source code in passive_auto_design\\space_mapping.py @functools . lru_cache () def cost_calc ( perf_list , goal_list , weight_list = None ): \"\"\" return the normalize standard deviation between the perf_list and the goal_list Parameters ---------- perf_list : tuple of float list of the performances achieved. goal_list : tuple of float list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval. weight_list : tuple of float, optional weightning of the goals. If set to None, all the weight are set to one. Returns ------- cost : float cost value \"\"\" if weight_list is None : weight_list = [ 1 ] * len ( goal_list ) cost = 0 for itern , goal in enumerate ( goal_list ): perf = perf_list [ itern ] goal = goal_list [ itern ] if isinstance ( goal , tuple ): err_min = max (( perf - goal [ 0 ]) / ( goal [ 0 ] if goal [ 0 ] != 0 else 1 ), 0 ) err_max = max (( goal [ 1 ] - perf ) / ( goal [ 1 ] if goal [ 1 ] != 0 else 1 ), 0 ) err = err_min + err_max else : err = ( perf - goal ) / ( goal if goal != 0 else 1 ) cost += weight_list [ itern ] * err ** 2 return cost","title":"cost_calc()"},{"location":"spacemap/#passive_auto_design.space_mapping.space_map","text":"Optimization function for space mapping algorithm. Parameters: Name Type Description Default coarse_model fun function evaluating the coarse model goals for a set of dimensions (dim) and parameters (par) required dim0 dict initial dimensions of the component required fine_model fun function evaluating the fine model goals for a set of dimensions (dim) required par0 dict initial parameters of the component coarse model required goal dict set of goal targeted by the algorithm required maxiter int maximal number of iteration. The default is 5. 5 Returns: Type Description dict final dimension of the component. Source code in passive_auto_design\\space_mapping.py def space_map ( coarse_model , dim0 , fine_model , par0 , goal , maxiter = 5 ): \"\"\" Optimization function for space mapping algorithm. Parameters ---------- coarse_model : fun function evaluating the coarse model goals for a set of dimensions (dim) and parameters (par) dim0 : dict initial dimensions of the component fine_model : fun function evaluating the fine model goals for a set of dimensions (dim) par0 : dict initial parameters of the component coarse model goal : dict set of goal targeted by the algorithm maxiter : int, optional maximal number of iteration. The default is 5. Returns ------- dim : dict final dimension of the component. par : dict final parameters of the component model. fine_mod : dict achieved goal. \"\"\" dim = dim0 par = par0 achieved_goal = goal for i in range ( maxiter ): # evaluate exact value using fine model achieved_goal = fine_model ( dim ) # alter coarse model parameters to better match fine model results res = minimize ( __refresh_coarse , __totuple ( par ), method = \"L-BFGS-B\" , args = ( par0 . keys (), dim , coarse_model , achieved_goal ), ) par = __todict ( par0 . keys (), res . x ) # find best solution according to coarse model res = minimize ( __cost_coarse , __totuple ( dim ), method = \"Powell\" , args = ( dim0 . keys (), par , coarse_model , goal ), ) dim = __todict ( dim0 . keys (), res . x ) return dim , par , achieved_goal","title":"space_map()"},{"location":"special/","text":"Define constants and function dedicated to RF-conception __pn_interpol ( pn_db , freq , f_int ) interpolator for phase noise Source code in passive_auto_design\\special.py def __pn_interpol ( pn_db , freq , f_int ): \"\"\" interpolator for phase noise \"\"\" a = ( pn_db [ 1 ] - pn_db [ 0 ]) / ( 10 * np . log10 ( freq [ 1 ] / freq [ 0 ])) b = pn_db [ 1 ] - a * 10 * np . log10 ( freq [ 1 ]) return b + a * 10 * np . log10 ( f_int ) friis ( f , gain ) Parameters: Name Type Description Default f np.Array List of the noise figure (in dB) of each block. required gain np.Array List of the gain of each block (in dB). required Returns: Type Description float Total noise figure of the system Source code in passive_auto_design\\special.py @njit ( cache = True ) def friis ( f , gain ): \"\"\" Parameters ---------- f : np.Array List of the noise figure (in dB) of each block. gain : np.Array List of the gain of each block (in dB). Returns ------- float Total noise figure of the system \"\"\" m = gain . shape [ 0 ] n = f . shape [ 0 ] if m != n - 1 : raise ValueError ( \"gain should have 1 item less than noise factor f\" ) g_tot = 1 f_lin = lin ( f ) res = f_lin [ 0 ] for i in range ( m ): g_tot *= lin ( gain [ i ]) res += ( f_lin [ i + 1 ] - 1 ) / g_tot return dB ( res ) int_phase_noise ( pn_db , freq , f_min = None , f_max = None ) Parameters: Name Type Description Default pn_db np.Array List of the phase noise in dBc/Hz required freq np.Array List of the corresponding frequency (in Hz) required f_min, f_max float if not None, calculation is done from f_min to f_max (with interpolation) required Returns: Type Description float integrated phase noise of the piece wise phase noise curve (in radian) Source code in passive_auto_design\\special.py def int_phase_noise ( pn_db , freq , f_min = None , f_max = None ): \"\"\" Parameters ---------- pn_db : np.Array List of the phase noise in dBc/Hz freq : np.Array List of the corresponding frequency (in Hz) f_min, f_max : float if not None, calculation is done from f_min to f_max (with interpolation) Returns ------- float integrated phase noise of the piece wise phase noise curve (in radian) \"\"\" pn_shape = pn_db . size f_shape = freq . size if pn_shape != f_shape : raise ValueError ( f \"Expected identical shape, got { pn_shape } and { f_shape } \" ) ipn = 0 for i in range ( pn_shape - 1 ): if f_min is not None and f_min > freq [ i + 1 ]: # skipping all part bellow f_min continue if f_min is not None and f_min > freq [ i ]: f1 = f_min pn1_db = __pn_interpol ( pn_db [ i : i + 2 ], freq [ i : i + 2 ], f_min ) else : f1 = freq [ i ] pn1_db = pn_db [ i ] if f_max is not None and freq [ i ] > f_max : continue if f_max is not None and freq [ i + 1 ] < f_max : f2 = f_max pn2_db = __pn_interpol ( pn_db [ i : i + 2 ], freq [ i : i + 2 ], f_max ) else : f2 = freq [ i + 1 ] pn2_db = pn_db [ i + 1 ] A = ( pn1_db - pn2_db ) / dB ( f1 / f2 ) ipn += ( f2 * lin ( pn2_db ) - f1 * lin ( pn1_db )) / ( A + 1 ) return ipn ipn_to_jitter ( ipn , f0 ) Parameters: Name Type Description Default ipn float integrated phase noise of an system required f0 float central frequency of the system required Returns: Type Description float equivalent jitter in seconds Source code in passive_auto_design\\special.py def ipn_to_jitter ( ipn , f0 ): \"\"\" Parameters ---------- ipn : float integrated phase noise of an system f0 : float central frequency of the system Returns ------- float equivalent jitter in seconds \"\"\" return np . sqrt ( 2 * ipn ) / ( 2 * np . pi * f0 ) reflexion_coef ( _z_steps , _phi_step ) return the coefficient reflexion of a given sequence of transmission lines with the given_z_steps profile and equal length of _phi_steps degrees Source code in passive_auto_design\\special.py @njit ( cache = True ) def reflexion_coef ( _z_steps , _phi_step ): \"\"\" return the coefficient reflexion of a given sequence of transmission lines with the given_z_steps profile and equal length of _phi_steps degrees \"\"\" n_step = len ( _z_steps ) z_tot = _z_steps [ - 1 :] for i in range ( n_step ): z_0 = _z_steps [ n_step - i - 1 ] z_tot = ( z_0 * ( z_tot + 1 j * z_0 * np . tan ( _phi_step )) / ( z_0 + 1 j * z_tot * np . tan ( _phi_step )) ) return gamma ( _z_steps [ 0 ], z_tot ) std_dev ( measured , targeted ) return the standard deviation between an array_like of results and their references. Source code in passive_auto_design\\special.py def std_dev ( measured , targeted ): \"\"\" return the standard deviation between an array_like of results and their references. \"\"\" tmp = np . array ( np . abs ( gamma ( measured , targeted )) ** 2 ) return np . sqrt ( np . sum ( tmp ))","title":"Special"},{"location":"special/#passive_auto_design.special.__pn_interpol","text":"interpolator for phase noise Source code in passive_auto_design\\special.py def __pn_interpol ( pn_db , freq , f_int ): \"\"\" interpolator for phase noise \"\"\" a = ( pn_db [ 1 ] - pn_db [ 0 ]) / ( 10 * np . log10 ( freq [ 1 ] / freq [ 0 ])) b = pn_db [ 1 ] - a * 10 * np . log10 ( freq [ 1 ]) return b + a * 10 * np . log10 ( f_int )","title":"__pn_interpol()"},{"location":"special/#passive_auto_design.special.friis","text":"Parameters: Name Type Description Default f np.Array List of the noise figure (in dB) of each block. required gain np.Array List of the gain of each block (in dB). required Returns: Type Description float Total noise figure of the system Source code in passive_auto_design\\special.py @njit ( cache = True ) def friis ( f , gain ): \"\"\" Parameters ---------- f : np.Array List of the noise figure (in dB) of each block. gain : np.Array List of the gain of each block (in dB). Returns ------- float Total noise figure of the system \"\"\" m = gain . shape [ 0 ] n = f . shape [ 0 ] if m != n - 1 : raise ValueError ( \"gain should have 1 item less than noise factor f\" ) g_tot = 1 f_lin = lin ( f ) res = f_lin [ 0 ] for i in range ( m ): g_tot *= lin ( gain [ i ]) res += ( f_lin [ i + 1 ] - 1 ) / g_tot return dB ( res )","title":"friis()"},{"location":"special/#passive_auto_design.special.int_phase_noise","text":"Parameters: Name Type Description Default pn_db np.Array List of the phase noise in dBc/Hz required freq np.Array List of the corresponding frequency (in Hz) required f_min, f_max float if not None, calculation is done from f_min to f_max (with interpolation) required Returns: Type Description float integrated phase noise of the piece wise phase noise curve (in radian) Source code in passive_auto_design\\special.py def int_phase_noise ( pn_db , freq , f_min = None , f_max = None ): \"\"\" Parameters ---------- pn_db : np.Array List of the phase noise in dBc/Hz freq : np.Array List of the corresponding frequency (in Hz) f_min, f_max : float if not None, calculation is done from f_min to f_max (with interpolation) Returns ------- float integrated phase noise of the piece wise phase noise curve (in radian) \"\"\" pn_shape = pn_db . size f_shape = freq . size if pn_shape != f_shape : raise ValueError ( f \"Expected identical shape, got { pn_shape } and { f_shape } \" ) ipn = 0 for i in range ( pn_shape - 1 ): if f_min is not None and f_min > freq [ i + 1 ]: # skipping all part bellow f_min continue if f_min is not None and f_min > freq [ i ]: f1 = f_min pn1_db = __pn_interpol ( pn_db [ i : i + 2 ], freq [ i : i + 2 ], f_min ) else : f1 = freq [ i ] pn1_db = pn_db [ i ] if f_max is not None and freq [ i ] > f_max : continue if f_max is not None and freq [ i + 1 ] < f_max : f2 = f_max pn2_db = __pn_interpol ( pn_db [ i : i + 2 ], freq [ i : i + 2 ], f_max ) else : f2 = freq [ i + 1 ] pn2_db = pn_db [ i + 1 ] A = ( pn1_db - pn2_db ) / dB ( f1 / f2 ) ipn += ( f2 * lin ( pn2_db ) - f1 * lin ( pn1_db )) / ( A + 1 ) return ipn","title":"int_phase_noise()"},{"location":"special/#passive_auto_design.special.ipn_to_jitter","text":"Parameters: Name Type Description Default ipn float integrated phase noise of an system required f0 float central frequency of the system required Returns: Type Description float equivalent jitter in seconds Source code in passive_auto_design\\special.py def ipn_to_jitter ( ipn , f0 ): \"\"\" Parameters ---------- ipn : float integrated phase noise of an system f0 : float central frequency of the system Returns ------- float equivalent jitter in seconds \"\"\" return np . sqrt ( 2 * ipn ) / ( 2 * np . pi * f0 )","title":"ipn_to_jitter()"},{"location":"special/#passive_auto_design.special.reflexion_coef","text":"return the coefficient reflexion of a given sequence of transmission lines with the given_z_steps profile and equal length of _phi_steps degrees Source code in passive_auto_design\\special.py @njit ( cache = True ) def reflexion_coef ( _z_steps , _phi_step ): \"\"\" return the coefficient reflexion of a given sequence of transmission lines with the given_z_steps profile and equal length of _phi_steps degrees \"\"\" n_step = len ( _z_steps ) z_tot = _z_steps [ - 1 :] for i in range ( n_step ): z_0 = _z_steps [ n_step - i - 1 ] z_tot = ( z_0 * ( z_tot + 1 j * z_0 * np . tan ( _phi_step )) / ( z_0 + 1 j * z_tot * np . tan ( _phi_step )) ) return gamma ( _z_steps [ 0 ], z_tot )","title":"reflexion_coef()"},{"location":"special/#passive_auto_design.special.std_dev","text":"return the standard deviation between an array_like of results and their references. Source code in passive_auto_design\\special.py def std_dev ( measured , targeted ): \"\"\" return the standard deviation between an array_like of results and their references. \"\"\" tmp = np . array ( np . abs ( gamma ( measured , targeted )) ** 2 ) return np . sqrt ( np . sum ( tmp ))","title":"std_dev()"},{"location":"unit/","text":"Some function to format physical dimensions. Impedance ( value ) Format complex impedance to string with engineer format. Source code in passive_auto_design\\unit.py def Impedance ( value ): \"\"\" Format complex impedance to string with engineer format. \"\"\" if imag ( value ) < 0 : return __res ( real ( value )) + \" - j\" + __res ( - imag ( value )) + r \" $\\Omega$\" return __res ( real ( value )) + \" + j\" + __res ( imag ( value )) + r \" $\\Omega$\"","title":"Unit"},{"location":"unit/#passive_auto_design.unit.Impedance","text":"Format complex impedance to string with engineer format. Source code in passive_auto_design\\unit.py def Impedance ( value ): \"\"\" Format complex impedance to string with engineer format. \"\"\" if imag ( value ) < 0 : return __res ( real ( value )) + \" - j\" + __res ( - imag ( value )) + r \" $\\Omega$\" return __res ( real ( value )) + \" + j\" + __res ( imag ( value )) + r \" $\\Omega$\"","title":"Impedance()"},{"location":"components/lumped_element/","text":"Capacitor ( LumpedElement ) class describing a capacitor behavior calc_ref_value ( self ) Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): return eps0 * self . par [ \"eps_r\" ] * self . par [ \"area\" ] / self . par [ \"dist\" ] Inductor ( LumpedElement ) class describing a inductor behavior calc_ref_value ( self ) Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): outer_diam = ( self . par [ \"d_i\" ] + 2 * self . par [ \"n_turn\" ] * self . par [ \"width\" ] + 2 * ( self . par [ \"n_turn\" ] - 1 ) * self . par [ \"gap\" ] ) self . par . update ({ \"d_o\" : outer_diam }) rho = ( self . par [ \"d_i\" ] + outer_diam ) / 2 density = ( outer_diam - self . par [ \"d_i\" ]) / ( outer_diam + self . par [ \"d_i\" ]) return ( self . par [ \"k_1\" ] * u0 * self . par [ \"n_turn\" ] ** 2 * rho / ( 1 + self . par [ \"k_2\" ] * density ) ) LumpedElement class of standard lumped element, to be inherited by all lumped elements par property writable Returns: Type Description Dictionary Parameters of the lumped component. calc_ref_value ( self ) Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py @abc . abstractmethod def calc_ref_value ( self ): \"\"\" Definition of the behavioral equation of the lumped element. Returns ------- Value of self.par[self.ref] calculated with the other value in self.par. \"\"\" set_x_with_y ( self , x_key , y_key , y_value ) set the value of the X_key for a Y_value of the Y_key Source code in passive_auto_design\\components\\lumped_element.py def set_x_with_y ( self , x_key , y_key , y_value ): \"\"\" set the value of the X_key for a Y_value of the Y_key \"\"\" minimize_scalar ( self . __cost , args = ( x_key , y_key , y_value )) Mutual ( LumpedElement ) class describing a mutual inductor behavior calc_ref_value ( self ) Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): cpl = self . par [ \"cpl_eq\" ] return cpl * ( min ( self . ind1 . par [ \"d_o\" ], self . ind2 . par [ \"d_o\" ]) - max ( self . ind1 . par [ \"d_i\" ], self . ind2 . par [ \"d_i\" ]) ) Resistor ( LumpedElement ) class describing a resistor behavior calc_ref_value ( self ) Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): return self . par [ \"rho\" ] * self . par [ \"length\" ] / self . par [ \"section\" ]","title":"Lumped Element"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Capacitor","text":"class describing a capacitor behavior","title":"Capacitor"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Capacitor.calc_ref_value","text":"Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): return eps0 * self . par [ \"eps_r\" ] * self . par [ \"area\" ] / self . par [ \"dist\" ]","title":"calc_ref_value()"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Inductor","text":"class describing a inductor behavior","title":"Inductor"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Inductor.calc_ref_value","text":"Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): outer_diam = ( self . par [ \"d_i\" ] + 2 * self . par [ \"n_turn\" ] * self . par [ \"width\" ] + 2 * ( self . par [ \"n_turn\" ] - 1 ) * self . par [ \"gap\" ] ) self . par . update ({ \"d_o\" : outer_diam }) rho = ( self . par [ \"d_i\" ] + outer_diam ) / 2 density = ( outer_diam - self . par [ \"d_i\" ]) / ( outer_diam + self . par [ \"d_i\" ]) return ( self . par [ \"k_1\" ] * u0 * self . par [ \"n_turn\" ] ** 2 * rho / ( 1 + self . par [ \"k_2\" ] * density ) )","title":"calc_ref_value()"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement","text":"class of standard lumped element, to be inherited by all lumped elements","title":"LumpedElement"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement.par","text":"Returns: Type Description Dictionary Parameters of the lumped component.","title":"par"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement.calc_ref_value","text":"Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py @abc . abstractmethod def calc_ref_value ( self ): \"\"\" Definition of the behavioral equation of the lumped element. Returns ------- Value of self.par[self.ref] calculated with the other value in self.par. \"\"\"","title":"calc_ref_value()"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement.set_x_with_y","text":"set the value of the X_key for a Y_value of the Y_key Source code in passive_auto_design\\components\\lumped_element.py def set_x_with_y ( self , x_key , y_key , y_value ): \"\"\" set the value of the X_key for a Y_value of the Y_key \"\"\" minimize_scalar ( self . __cost , args = ( x_key , y_key , y_value ))","title":"set_x_with_y()"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Mutual","text":"class describing a mutual inductor behavior","title":"Mutual"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Mutual.calc_ref_value","text":"Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): cpl = self . par [ \"cpl_eq\" ] return cpl * ( min ( self . ind1 . par [ \"d_o\" ], self . ind2 . par [ \"d_o\" ]) - max ( self . ind1 . par [ \"d_i\" ], self . ind2 . par [ \"d_i\" ]) )","title":"calc_ref_value()"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Resistor","text":"class describing a resistor behavior","title":"Resistor"},{"location":"components/lumped_element/#passive_auto_design.components.lumped_element.Resistor.calc_ref_value","text":"Definition of the behavioral equation of the lumped element. Source code in passive_auto_design\\components\\lumped_element.py def calc_ref_value ( self ): return self . par [ \"rho\" ] * self . par [ \"length\" ] / self . par [ \"section\" ]","title":"calc_ref_value()"},{"location":"components/taper/","text":"This module give function to ease the design of RF-tapper klopfenstein_taper ( _z_start , _z_stop , _n_step , _rhomax = 0.01 ) return the _n_step profile of impedance for a transition from _z_start to _z_stop Source code in passive_auto_design\\components\\taper.py def klopfenstein_taper ( _z_start , _z_stop , _n_step , _rhomax = 0.01 ): \"\"\" return the _n_step profile of impedance for a transition from _z_start to _z_stop \"\"\" rho0 = gamma ( _z_start , _z_stop ) z_mid = 0.5 * np . log ( _z_stop * _z_start ) n_mid = int ( np . floor ( _n_step / 2 )) a_coeff = np . arccosh ( rho0 / _rhomax ) ln_z = np . zeros (( _n_step ,)) for i in range ( 1 , n_mid + 1 ): ln_z [ i + n_mid ] = z_mid + _rhomax * ( 1 + a_coeff ** 2 * __phi ( a_coeff , i / n_mid ) ) ln_z [ n_mid - i ] = z_mid + _rhomax * ( 1 - a_coeff ** 2 * __phi ( a_coeff , i / n_mid ) ) ln_z [ n_mid ] = z_mid + _rhomax return np . exp ( ln_z , dtype = complex ) linear_taper ( _z_start , _z_stop , _n_step ) return the _n_step profile of impedance for a transition from _z_start to _z_stop Source code in passive_auto_design\\components\\taper.py def linear_taper ( _z_start , _z_stop , _n_step ): \"\"\" return the _n_step profile of impedance for a transition from _z_start to _z_stop \"\"\" return np . linspace ( _z_start , _z_stop , _n_step , dtype = complex )","title":"Taper"},{"location":"components/taper/#passive_auto_design.components.taper.klopfenstein_taper","text":"return the _n_step profile of impedance for a transition from _z_start to _z_stop Source code in passive_auto_design\\components\\taper.py def klopfenstein_taper ( _z_start , _z_stop , _n_step , _rhomax = 0.01 ): \"\"\" return the _n_step profile of impedance for a transition from _z_start to _z_stop \"\"\" rho0 = gamma ( _z_start , _z_stop ) z_mid = 0.5 * np . log ( _z_stop * _z_start ) n_mid = int ( np . floor ( _n_step / 2 )) a_coeff = np . arccosh ( rho0 / _rhomax ) ln_z = np . zeros (( _n_step ,)) for i in range ( 1 , n_mid + 1 ): ln_z [ i + n_mid ] = z_mid + _rhomax * ( 1 + a_coeff ** 2 * __phi ( a_coeff , i / n_mid ) ) ln_z [ n_mid - i ] = z_mid + _rhomax * ( 1 - a_coeff ** 2 * __phi ( a_coeff , i / n_mid ) ) ln_z [ n_mid ] = z_mid + _rhomax return np . exp ( ln_z , dtype = complex )","title":"klopfenstein_taper()"},{"location":"components/taper/#passive_auto_design.components.taper.linear_taper","text":"return the _n_step profile of impedance for a transition from _z_start to _z_stop Source code in passive_auto_design\\components\\taper.py def linear_taper ( _z_start , _z_stop , _n_step ): \"\"\" return the _n_step profile of impedance for a transition from _z_start to _z_stop \"\"\" return np . linspace ( _z_start , _z_stop , _n_step , dtype = complex )","title":"linear_taper()"},{"location":"components/transformer/","text":"Transformer Create a transformer object with the specified geometry _primary & _secondary (which are dict defined as : {'di':_di,'n_turn':_n_turn, 'width':_width, 'gap':_gap, 'height':height}) and calculate the associated electrical model cc_geo ( self , _mutual = True ) return the value of the distributed capacitance of the described transformer if _mutual, return the capacitance between primary and secondary else, return the capacitance to the ground plane Source code in passive_auto_design\\components\\transformer.py def cc_geo ( self , _mutual = True ): \"\"\" return the value of the distributed capacitance of the described transformer if _mutual, return the capacitance between primary and secondary else, return the capacitance to the ground plane \"\"\" if _mutual : dist = float ( self . model_map [ \"d_m\" ]) else : dist = float ( self . model_map [ \"d_g\" ]) n_t = self . prim [ \"n_turn\" ] eps_r = float ( self . model_map [ \"eps_r\" ]) area = n_t * self . prim [ \"di\" ] * self . prim [ \"width\" ] cap = lmp . Capacitor ( area , dist , eps_r ) return cap . par [ \"cap\" ] k_geo ( self ) return the value of the coupling between the two inductors. Source code in passive_auto_design\\components\\transformer.py def k_geo ( self ): \"\"\" return the value of the coupling between the two inductors. \"\"\" return self . model_map [ \"cpl_eq\" ] l_geo ( self , _of_primary = True ) return the value of the distributed inductance of the described transformer if _of_primary, return the value of the top inductor else, return the value of the bottom inductor Source code in passive_auto_design\\components\\transformer.py def l_geo ( self , _of_primary = True ): \"\"\" return the value of the distributed inductance of the described transformer if _of_primary, return the value of the top inductor else, return the value of the bottom inductor \"\"\" k_1 = float ( self . model_map [ \"mu_r\" ]) # constante1 empirique pour inductance k_2 = float ( self . model_map [ \"dens\" ]) # constante2 empirique pour inductance if _of_primary : geo = self . prim else : geo = self . second outer_diam = ( geo [ \"di\" ] + 2 * geo [ \"n_turn\" ] * geo [ \"width\" ] + 2 * ( geo [ \"n_turn\" ] - 1 ) * geo [ \"gap\" ] ) rho = ( geo [ \"di\" ] + outer_diam ) / 2 density = ( outer_diam - geo [ \"di\" ]) / ( outer_diam + geo [ \"di\" ]) return k_1 * u0 * geo [ \"n_turn\" ] ** 2 * rho / ( 1 + k_2 * density ) mutual_geo ( self , z_0 = 50 ) Create a transformateur with a primary of l_1, and secondary of l_2 and a coupling factor of k_mut Source code in passive_auto_design\\components\\transformer.py def mutual_geo ( self , z_0 = 50 ): \"\"\" Create a transformateur with a primary of l_1, and secondary of l_2 and a coupling factor of k_mut \"\"\" l_1 = self . model [ \"lp\" ] l_2 = self . model [ \"ls\" ] r_1 = self . model [ \"rp\" ] r_2 = self . model [ \"rs\" ] k_mut = self . model [ \"k\" ] for f_t in self . freq . f : w_t = float ( 2 * np . pi * f_t ) y_1 = 1 / ( r_1 + 1 j * w_t * l_1 * ( 1 - k_mut ** 2 )) y_2 = 1 / ( r_2 + 1 j * w_t * l_2 * ( 1 - k_mut ** 2 )) y_m = k_mut / ( 1e-30 + 1 j * w_t * np . sqrt ( l_1 * l_2 ) * ( 1 - k_mut ** 2 )) y_param = np . array ( [ [ [ y_1 , - y_m , y_m , - y_1 ], [ - y_m , y_2 , - y_2 , y_m ], [ y_m , - y_2 , y_2 , - y_m ], [ - y_1 , y_m , - y_m , y_1 ], ] ] ) try : y_params = np . vstack (( y_params , y_param )) except NameError : # Only needed for first iteration. y_params = np . copy ( y_param ) ntwk = rf . Network ( frequency = self . freq , s = rf . y2s ( y_params ), z0 = z_0 , name = \"coupled inductors\" ) return ntwk r_geo ( self , _of_primary = True ) return the value of the resistance of the described transformer Source code in passive_auto_design\\components\\transformer.py def r_geo ( self , _of_primary = True ): \"\"\" return the value of the resistance of the described transformer \"\"\" if _of_primary : geo = self . prim else : geo = self . second rho = self . model_map [ \"rho\" ] n_t = geo [ \"n_turn\" ] l_tot = ( 8 * np . tan ( np . pi / 8 ) * n_t * ( geo [ \"di\" ] + geo [ \"width\" ] + ( n_t - 1 ) * ( geo [ \"width\" ] + geo [ \"gap\" ])) ) r_dc = rho * l_tot / geo [ \"width\" ] return np . maximum ( r_dc , 0 ) set_primary ( self , _primary ) modify the top inductor and refresh the related model parameters Source code in passive_auto_design\\components\\transformer.py def set_primary ( self , _primary ): \"\"\" modify the top inductor and refresh the related model parameters \"\"\" self . prim = _primary self . model . update ( { \"lp\" : self . l_geo ( True ), \"rp\" : self . r_geo ( True ), \"cg\" : self . cc_geo ( False ), \"cm\" : self . cc_geo ( True ), \"k\" : self . k_geo (), } ) try : self . circuit = self . __make_circuit () except KeyError : pass set_secondary ( self , _secondary ) modify the bottom inductor and refresh the related model parameters Source code in passive_auto_design\\components\\transformer.py def set_secondary ( self , _secondary ): \"\"\" modify the bottom inductor and refresh the related model parameters \"\"\" self . second = _secondary self . model . update ( { \"ls\" : self . l_geo ( False ), \"rs\" : self . r_geo ( False ), \"cg\" : self . cc_geo ( False ), \"cm\" : self . cc_geo ( True ), \"k\" : self . k_geo (), } ) try : self . circuit = self . __make_circuit () except KeyError : pass","title":"Transformer"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer","text":"Create a transformer object with the specified geometry _primary & _secondary (which are dict defined as : {'di':_di,'n_turn':_n_turn, 'width':_width, 'gap':_gap, 'height':height}) and calculate the associated electrical model","title":"Transformer"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.cc_geo","text":"return the value of the distributed capacitance of the described transformer if _mutual, return the capacitance between primary and secondary else, return the capacitance to the ground plane Source code in passive_auto_design\\components\\transformer.py def cc_geo ( self , _mutual = True ): \"\"\" return the value of the distributed capacitance of the described transformer if _mutual, return the capacitance between primary and secondary else, return the capacitance to the ground plane \"\"\" if _mutual : dist = float ( self . model_map [ \"d_m\" ]) else : dist = float ( self . model_map [ \"d_g\" ]) n_t = self . prim [ \"n_turn\" ] eps_r = float ( self . model_map [ \"eps_r\" ]) area = n_t * self . prim [ \"di\" ] * self . prim [ \"width\" ] cap = lmp . Capacitor ( area , dist , eps_r ) return cap . par [ \"cap\" ]","title":"cc_geo()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.k_geo","text":"return the value of the coupling between the two inductors. Source code in passive_auto_design\\components\\transformer.py def k_geo ( self ): \"\"\" return the value of the coupling between the two inductors. \"\"\" return self . model_map [ \"cpl_eq\" ]","title":"k_geo()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.l_geo","text":"return the value of the distributed inductance of the described transformer if _of_primary, return the value of the top inductor else, return the value of the bottom inductor Source code in passive_auto_design\\components\\transformer.py def l_geo ( self , _of_primary = True ): \"\"\" return the value of the distributed inductance of the described transformer if _of_primary, return the value of the top inductor else, return the value of the bottom inductor \"\"\" k_1 = float ( self . model_map [ \"mu_r\" ]) # constante1 empirique pour inductance k_2 = float ( self . model_map [ \"dens\" ]) # constante2 empirique pour inductance if _of_primary : geo = self . prim else : geo = self . second outer_diam = ( geo [ \"di\" ] + 2 * geo [ \"n_turn\" ] * geo [ \"width\" ] + 2 * ( geo [ \"n_turn\" ] - 1 ) * geo [ \"gap\" ] ) rho = ( geo [ \"di\" ] + outer_diam ) / 2 density = ( outer_diam - geo [ \"di\" ]) / ( outer_diam + geo [ \"di\" ]) return k_1 * u0 * geo [ \"n_turn\" ] ** 2 * rho / ( 1 + k_2 * density )","title":"l_geo()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.mutual_geo","text":"Create a transformateur with a primary of l_1, and secondary of l_2 and a coupling factor of k_mut Source code in passive_auto_design\\components\\transformer.py def mutual_geo ( self , z_0 = 50 ): \"\"\" Create a transformateur with a primary of l_1, and secondary of l_2 and a coupling factor of k_mut \"\"\" l_1 = self . model [ \"lp\" ] l_2 = self . model [ \"ls\" ] r_1 = self . model [ \"rp\" ] r_2 = self . model [ \"rs\" ] k_mut = self . model [ \"k\" ] for f_t in self . freq . f : w_t = float ( 2 * np . pi * f_t ) y_1 = 1 / ( r_1 + 1 j * w_t * l_1 * ( 1 - k_mut ** 2 )) y_2 = 1 / ( r_2 + 1 j * w_t * l_2 * ( 1 - k_mut ** 2 )) y_m = k_mut / ( 1e-30 + 1 j * w_t * np . sqrt ( l_1 * l_2 ) * ( 1 - k_mut ** 2 )) y_param = np . array ( [ [ [ y_1 , - y_m , y_m , - y_1 ], [ - y_m , y_2 , - y_2 , y_m ], [ y_m , - y_2 , y_2 , - y_m ], [ - y_1 , y_m , - y_m , y_1 ], ] ] ) try : y_params = np . vstack (( y_params , y_param )) except NameError : # Only needed for first iteration. y_params = np . copy ( y_param ) ntwk = rf . Network ( frequency = self . freq , s = rf . y2s ( y_params ), z0 = z_0 , name = \"coupled inductors\" ) return ntwk","title":"mutual_geo()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.r_geo","text":"return the value of the resistance of the described transformer Source code in passive_auto_design\\components\\transformer.py def r_geo ( self , _of_primary = True ): \"\"\" return the value of the resistance of the described transformer \"\"\" if _of_primary : geo = self . prim else : geo = self . second rho = self . model_map [ \"rho\" ] n_t = geo [ \"n_turn\" ] l_tot = ( 8 * np . tan ( np . pi / 8 ) * n_t * ( geo [ \"di\" ] + geo [ \"width\" ] + ( n_t - 1 ) * ( geo [ \"width\" ] + geo [ \"gap\" ])) ) r_dc = rho * l_tot / geo [ \"width\" ] return np . maximum ( r_dc , 0 )","title":"r_geo()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.set_primary","text":"modify the top inductor and refresh the related model parameters Source code in passive_auto_design\\components\\transformer.py def set_primary ( self , _primary ): \"\"\" modify the top inductor and refresh the related model parameters \"\"\" self . prim = _primary self . model . update ( { \"lp\" : self . l_geo ( True ), \"rp\" : self . r_geo ( True ), \"cg\" : self . cc_geo ( False ), \"cm\" : self . cc_geo ( True ), \"k\" : self . k_geo (), } ) try : self . circuit = self . __make_circuit () except KeyError : pass","title":"set_primary()"},{"location":"components/transformer/#passive_auto_design.components.transformer.Transformer.set_secondary","text":"modify the bottom inductor and refresh the related model parameters Source code in passive_auto_design\\components\\transformer.py def set_secondary ( self , _secondary ): \"\"\" modify the bottom inductor and refresh the related model parameters \"\"\" self . second = _secondary self . model . update ( { \"ls\" : self . l_geo ( False ), \"rs\" : self . r_geo ( False ), \"cg\" : self . cc_geo ( False ), \"cm\" : self . cc_geo ( True ), \"k\" : self . k_geo (), } ) try : self . circuit = self . __make_circuit () except KeyError : pass","title":"set_secondary()"},{"location":"components/waveguide/","text":"AF_SIW ( Waveguide ) Create an AF-SIW object with a given geometry calc_a_d ( self , _freq ) return the value of the dielectric loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_d ( self , _freq ): return 0 calc_ksr ( self , _freq ) return the coefficient of the added conductor loss introduce by surface roughness Source code in passive_auto_design\\components\\waveguide.py def calc_ksr ( self , _freq ): rho = self . metal . rho skin_d = 1 / np . sqrt ( rho * np . pi * _freq * u0 ) rough = self . metal . roughness return 2 * np . arctan ( 1.4 * ( rough / skin_d ) ** 2 ) / np . pi f_cut_off ( self , _m = 1 , _n = 0 ) return the value of the cut-off frequency of the TEM mode _m, _n Source code in passive_auto_design\\components\\waveguide.py def f_cut_off ( self , _m = 1 , _n = 0 ) -> float : \"\"\" return the value of the cut-off frequency of the TEM mode _m, _n \"\"\" if _n > 0 : raise ValueError ( \"Value of _n greater than 0 are not supported\" ) if _m % 2 == 1 : res = minimize_scalar ( self . __odd_fc ) else : f_c = self . f_c res = minimize_scalar ( self . __even_fc , bounds = ( 1.5 * f_c , 5 * f_c ), method = \"bounded\" ) return res . x print_info ( self ) output the size and the upper mode cut-off frequency Source code in passive_auto_design\\components\\waveguide.py def print_info ( self ): \"\"\" output the size and the upper mode cut-off frequency \"\"\" fc_20 = self . f_cut_off ( 2 , 0 ) print ( f \"Width: { self . width * 1e3 : .2f } mm \\t fc20: { fc_20 * 1e-9 : .2f } GHz\" ) Waveguide Create an SIW object with a given geometry calc_a_c ( self , _freq ) return the value of the conductor loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_c ( self , _freq ): \"\"\" return the value of the conductor loss in dB/m at the frequency freq (array-like) \"\"\" r_s = np . sqrt ( 2 * np . pi * _freq * u0 / ( 2 * self . metal . rho )) eta = self . eta k = self . calc_k ( _freq ) beta = self . calc_beta ( _freq ) height = self . height width = self . width return ( Nm_to_dBcm * r_s * ( 2 * height * np . pi ** 2 + width ** 3 * k ** 2 ) / (( width ** 3 ) * height * beta * k * eta ) ) calc_a_d ( self , _freq ) return the value of the dielectric loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_d ( self , _freq ): \"\"\" return the value of the dielectric loss in dB/m at the frequency freq (array-like) \"\"\" k = self . calc_k ( _freq ) tan_d = self . diel . tan_d beta = self . calc_beta ( _freq ) return Nm_to_dBcm * k ** 2 * tan_d / ( 2 * beta ) calc_beta ( self , _freq ) return the value of the velocity (beta) Source code in passive_auto_design\\components\\waveguide.py def calc_beta ( self , _freq ): \"\"\" return the value of the velocity (beta) \"\"\" return np . sqrt ( self . calc_k ( _freq ) ** 2 - ( np . pi / self . width ) ** 2 ) calc_k ( self , _freq ) convert the freq in pulsation in the given substrate Source code in passive_auto_design\\components\\waveguide.py def calc_k ( self , _freq ): \"\"\" convert the freq in pulsation in the given substrate \"\"\" return np . sqrt ( self . diel . epsilon ) * 2 * np . pi * _freq / c0 calc_ksr ( self , _freq ) return the coefficient of the added conductor loss introduce by surface roughness Source code in passive_auto_design\\components\\waveguide.py def calc_ksr ( self , _freq ): \"\"\" return the coefficient of the added conductor loss introduce by surface roughness \"\"\" rho = self . metal . rho skin_d = 1 / np . sqrt ( rho * np . pi * _freq * u0 ) rough = self . diel . roughness if rough <= 0 : raise ValueError ( \"Roughness must be above zero. \\ Value can be set through /self.diel.roughness/\" ) return 2 * np . arctan ( 1.4 * ( rough / skin_d ) ** 2 ) / np . pi calc_lambda ( self , _f ) return the wavelength inside the waveguide at the given frequency _f Source code in passive_auto_design\\components\\waveguide.py def calc_lambda ( self , _f ): \"\"\" return the wavelength inside the waveguide at the given frequency _f \"\"\" return c0 / ( _f * np . sqrt ( 1 - ( self . f_c / _f ) ** 2 )) calc_pphc ( self , _freq , _e_0 ) return the peak power handling capability in watt at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m) Source code in passive_auto_design\\components\\waveguide.py def calc_pphc ( self , _freq , _e_0 ): \"\"\" return the peak power handling capability in watt at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m) \"\"\" width = self . width if width <= 0.0 : raise ValueError ( \"Width must be above zero. \\ Value can be set using set_width() or set_f_c()\" ) height = self . height f_c = self . first_cut_off eps = self . diel . epsilon return ( 0.25 * np . sqrt ( eps ) * np . sqrt ( 1 - ( f_c / _freq ) ** 2 ) * width * height * _e_0 ** 2 / eta0 ) f_cut_off ( self , _m = 1 , _n = 0 ) return the value of the cut-off frequency of the TEM mode _m, _n Source code in passive_auto_design\\components\\waveguide.py def f_cut_off ( self , _m = 1 , _n = 0 ): \"\"\" return the value of the cut-off frequency of the TEM mode _m, _n \"\"\" eps = self . diel . epsilon return ( c0 * np . sqrt (( _m * np . pi / self . width ) ** 2 + ( _n * np . pi / self . height ) ** 2 ) / ( 2 * np . pi * np . sqrt ( eps )) ) get_sparam ( self , _freq , _length ) return the 4 scattering parameters of a wave-guide section of the given length for the given frequency Source code in passive_auto_design\\components\\waveguide.py def get_sparam ( self , _freq , _length ): \"\"\" return the 4 scattering parameters of a wave-guide section of the given length for the given frequency \"\"\" s11 = 0 alpha = self . calc_a_c ( _freq ) + ( 1 + self . calc_ksr ( _freq )) * self . calc_a_d ( _freq ) s21 = ( 1 - s11 ) * np . exp ( - ( alpha + 1 j * self . calc_beta ( _freq )) * _length ) return s21 print_info ( self ) output the size and the upper mode cut-off frequency Source code in passive_auto_design\\components\\waveguide.py def print_info ( self ): \"\"\" output the size and the upper mode cut-off frequency \"\"\" fc_01 = self . f_cut_off ( 0 , 1 ) print ( f \"Width: { self . width * 1e3 : .2f } mm \\t fc01: { fc_01 * 1e-9 : .2f } GHz\" )","title":"Waveguide"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.AF_SIW","text":"Create an AF-SIW object with a given geometry","title":"AF_SIW"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.calc_a_d","text":"return the value of the dielectric loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_d ( self , _freq ): return 0","title":"calc_a_d()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.calc_ksr","text":"return the coefficient of the added conductor loss introduce by surface roughness Source code in passive_auto_design\\components\\waveguide.py def calc_ksr ( self , _freq ): rho = self . metal . rho skin_d = 1 / np . sqrt ( rho * np . pi * _freq * u0 ) rough = self . metal . roughness return 2 * np . arctan ( 1.4 * ( rough / skin_d ) ** 2 ) / np . pi","title":"calc_ksr()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.f_cut_off","text":"return the value of the cut-off frequency of the TEM mode _m, _n Source code in passive_auto_design\\components\\waveguide.py def f_cut_off ( self , _m = 1 , _n = 0 ) -> float : \"\"\" return the value of the cut-off frequency of the TEM mode _m, _n \"\"\" if _n > 0 : raise ValueError ( \"Value of _n greater than 0 are not supported\" ) if _m % 2 == 1 : res = minimize_scalar ( self . __odd_fc ) else : f_c = self . f_c res = minimize_scalar ( self . __even_fc , bounds = ( 1.5 * f_c , 5 * f_c ), method = \"bounded\" ) return res . x","title":"f_cut_off()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.print_info","text":"output the size and the upper mode cut-off frequency Source code in passive_auto_design\\components\\waveguide.py def print_info ( self ): \"\"\" output the size and the upper mode cut-off frequency \"\"\" fc_20 = self . f_cut_off ( 2 , 0 ) print ( f \"Width: { self . width * 1e3 : .2f } mm \\t fc20: { fc_20 * 1e-9 : .2f } GHz\" )","title":"print_info()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide","text":"Create an SIW object with a given geometry","title":"Waveguide"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_a_c","text":"return the value of the conductor loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_c ( self , _freq ): \"\"\" return the value of the conductor loss in dB/m at the frequency freq (array-like) \"\"\" r_s = np . sqrt ( 2 * np . pi * _freq * u0 / ( 2 * self . metal . rho )) eta = self . eta k = self . calc_k ( _freq ) beta = self . calc_beta ( _freq ) height = self . height width = self . width return ( Nm_to_dBcm * r_s * ( 2 * height * np . pi ** 2 + width ** 3 * k ** 2 ) / (( width ** 3 ) * height * beta * k * eta ) )","title":"calc_a_c()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_a_d","text":"return the value of the dielectric loss in dB/m at the frequency freq (array-like) Source code in passive_auto_design\\components\\waveguide.py def calc_a_d ( self , _freq ): \"\"\" return the value of the dielectric loss in dB/m at the frequency freq (array-like) \"\"\" k = self . calc_k ( _freq ) tan_d = self . diel . tan_d beta = self . calc_beta ( _freq ) return Nm_to_dBcm * k ** 2 * tan_d / ( 2 * beta )","title":"calc_a_d()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_beta","text":"return the value of the velocity (beta) Source code in passive_auto_design\\components\\waveguide.py def calc_beta ( self , _freq ): \"\"\" return the value of the velocity (beta) \"\"\" return np . sqrt ( self . calc_k ( _freq ) ** 2 - ( np . pi / self . width ) ** 2 )","title":"calc_beta()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_k","text":"convert the freq in pulsation in the given substrate Source code in passive_auto_design\\components\\waveguide.py def calc_k ( self , _freq ): \"\"\" convert the freq in pulsation in the given substrate \"\"\" return np . sqrt ( self . diel . epsilon ) * 2 * np . pi * _freq / c0","title":"calc_k()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_ksr","text":"return the coefficient of the added conductor loss introduce by surface roughness Source code in passive_auto_design\\components\\waveguide.py def calc_ksr ( self , _freq ): \"\"\" return the coefficient of the added conductor loss introduce by surface roughness \"\"\" rho = self . metal . rho skin_d = 1 / np . sqrt ( rho * np . pi * _freq * u0 ) rough = self . diel . roughness if rough <= 0 : raise ValueError ( \"Roughness must be above zero. \\ Value can be set through /self.diel.roughness/\" ) return 2 * np . arctan ( 1.4 * ( rough / skin_d ) ** 2 ) / np . pi","title":"calc_ksr()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_lambda","text":"return the wavelength inside the waveguide at the given frequency _f Source code in passive_auto_design\\components\\waveguide.py def calc_lambda ( self , _f ): \"\"\" return the wavelength inside the waveguide at the given frequency _f \"\"\" return c0 / ( _f * np . sqrt ( 1 - ( self . f_c / _f ) ** 2 ))","title":"calc_lambda()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_pphc","text":"return the peak power handling capability in watt at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m) Source code in passive_auto_design\\components\\waveguide.py def calc_pphc ( self , _freq , _e_0 ): \"\"\" return the peak power handling capability in watt at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m) \"\"\" width = self . width if width <= 0.0 : raise ValueError ( \"Width must be above zero. \\ Value can be set using set_width() or set_f_c()\" ) height = self . height f_c = self . first_cut_off eps = self . diel . epsilon return ( 0.25 * np . sqrt ( eps ) * np . sqrt ( 1 - ( f_c / _freq ) ** 2 ) * width * height * _e_0 ** 2 / eta0 )","title":"calc_pphc()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.f_cut_off","text":"return the value of the cut-off frequency of the TEM mode _m, _n Source code in passive_auto_design\\components\\waveguide.py def f_cut_off ( self , _m = 1 , _n = 0 ): \"\"\" return the value of the cut-off frequency of the TEM mode _m, _n \"\"\" eps = self . diel . epsilon return ( c0 * np . sqrt (( _m * np . pi / self . width ) ** 2 + ( _n * np . pi / self . height ) ** 2 ) / ( 2 * np . pi * np . sqrt ( eps )) )","title":"f_cut_off()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.get_sparam","text":"return the 4 scattering parameters of a wave-guide section of the given length for the given frequency Source code in passive_auto_design\\components\\waveguide.py def get_sparam ( self , _freq , _length ): \"\"\" return the 4 scattering parameters of a wave-guide section of the given length for the given frequency \"\"\" s11 = 0 alpha = self . calc_a_c ( _freq ) + ( 1 + self . calc_ksr ( _freq )) * self . calc_a_d ( _freq ) s21 = ( 1 - s11 ) * np . exp ( - ( alpha + 1 j * self . calc_beta ( _freq )) * _length ) return s21","title":"get_sparam()"},{"location":"components/waveguide/#passive_auto_design.components.waveguide.Waveguide.print_info","text":"output the size and the upper mode cut-off frequency Source code in passive_auto_design\\components\\waveguide.py def print_info ( self ): \"\"\" output the size and the upper mode cut-off frequency \"\"\" fc_01 = self . f_cut_off ( 0 , 1 ) print ( f \"Width: { self . width * 1e3 : .2f } mm \\t fc01: { fc_01 * 1e-9 : .2f } GHz\" )","title":"print_info()"},{"location":"devices/balun/","text":"Class to calculate the inductors values of an impedance transformer. Balun Create a balun object design ( self ) design an impedance transformer with the targeted specifications (f_targ, zl_targ, zs_targ, k) return the two ideal transformers solution Source code in passive_auto_design\\devices\\balun.py def design ( self ): \"\"\" design an impedance transformer with the targeted specifications (f_targ, zl_targ, zs_targ, k) return the two ideal transformers solution \"\"\" k = self . k alpha = ( 1 - k ** 2 ) / k q_s = - quality_f ( self . z_src ) q_l = - quality_f ( self . z_ld ) # assuming perfect inductor for first calculation r_l1 = 0 r_l2 = 0 q_s_prime = q_s * np . real ( self . z_src ) / ( np . real ( self . z_src ) + r_l1 ) q_l_prime = q_l * np . real ( self . z_ld ) / ( np . real ( self . z_ld ) + r_l2 ) b_coeff = 2 * alpha * q_s_prime + q_s_prime + q_l_prime discr = b_coeff ** 2 - 4 * alpha * ( alpha + 1 ) * ( 1 + q_s_prime ** 2 ) if discr < 0 : raise ValueError ( \"Negative value in square root, \\ try to increase the coupling factor or the load quality factor \\ or try to lower the source quality factor\" ) z_sol = np . array ( ( ( b_coeff + np . sqrt ( discr )) / ( 2 * ( alpha + 1 )), ( b_coeff - np . sqrt ( discr )) / ( 2 * ( alpha + 1 )), ) ) qxl1 = z_sol / ( 1 - k ** 2 ) qxl2 = z_sol * ( 1 + q_l_prime ** 2 ) / ( alpha * ( 1 + ( q_s_prime - z_sol ) ** 2 )) l_sol1 = qxl1 * np . real ( self . z_src ) / ( 2 * np . pi * self . f_c ) l_sol2 = qxl2 * np . real ( self . z_ld ) / ( 2 * np . pi * self . f_c ) return l_sol1 , l_sol2 enforce_symmetrical ( self , side = 'load' , _verbose = False ) alter the value of the load impedance (if side=\"load\") or the source impedance in order to realize a symmetrical balun (ie. primary = secondary) Source code in passive_auto_design\\devices\\balun.py def enforce_symmetrical ( self , side = \"load\" , _verbose = False ): \"\"\" alter the value of the load impedance (if side=\"load\") or the source impedance in order to realize a symmetrical balun (ie. primary = secondary) \"\"\" if side == \"load\" : old_z = self . z_ld _through_load = True else : old_z = self . z_src _through_load = False res = minimize ( self . __enforce_symmetrical , - quality_f ( old_z ), args = _through_load , method = \"Nelder-Mead\" , ) new_z = np . real ( old_z ) * ( 1 - 1 j * res . x [ 0 ]) if _verbose : print ( f \"old z_ld: $ { complex ( old_z ) : 5.2f } \" ) print ( f \"new z_ld: $ { complex ( new_z ) : 5.2f } \" ) if _through_load : self . z_ld = complex ( new_z ) else : self . z_src = complex ( new_z )","title":"Balun"},{"location":"devices/balun/#passive_auto_design.devices.balun.Balun","text":"Create a balun object","title":"Balun"},{"location":"devices/balun/#passive_auto_design.devices.balun.Balun.design","text":"design an impedance transformer with the targeted specifications (f_targ, zl_targ, zs_targ, k) return the two ideal transformers solution Source code in passive_auto_design\\devices\\balun.py def design ( self ): \"\"\" design an impedance transformer with the targeted specifications (f_targ, zl_targ, zs_targ, k) return the two ideal transformers solution \"\"\" k = self . k alpha = ( 1 - k ** 2 ) / k q_s = - quality_f ( self . z_src ) q_l = - quality_f ( self . z_ld ) # assuming perfect inductor for first calculation r_l1 = 0 r_l2 = 0 q_s_prime = q_s * np . real ( self . z_src ) / ( np . real ( self . z_src ) + r_l1 ) q_l_prime = q_l * np . real ( self . z_ld ) / ( np . real ( self . z_ld ) + r_l2 ) b_coeff = 2 * alpha * q_s_prime + q_s_prime + q_l_prime discr = b_coeff ** 2 - 4 * alpha * ( alpha + 1 ) * ( 1 + q_s_prime ** 2 ) if discr < 0 : raise ValueError ( \"Negative value in square root, \\ try to increase the coupling factor or the load quality factor \\ or try to lower the source quality factor\" ) z_sol = np . array ( ( ( b_coeff + np . sqrt ( discr )) / ( 2 * ( alpha + 1 )), ( b_coeff - np . sqrt ( discr )) / ( 2 * ( alpha + 1 )), ) ) qxl1 = z_sol / ( 1 - k ** 2 ) qxl2 = z_sol * ( 1 + q_l_prime ** 2 ) / ( alpha * ( 1 + ( q_s_prime - z_sol ) ** 2 )) l_sol1 = qxl1 * np . real ( self . z_src ) / ( 2 * np . pi * self . f_c ) l_sol2 = qxl2 * np . real ( self . z_ld ) / ( 2 * np . pi * self . f_c ) return l_sol1 , l_sol2","title":"design()"},{"location":"devices/balun/#passive_auto_design.devices.balun.Balun.enforce_symmetrical","text":"alter the value of the load impedance (if side=\"load\") or the source impedance in order to realize a symmetrical balun (ie. primary = secondary) Source code in passive_auto_design\\devices\\balun.py def enforce_symmetrical ( self , side = \"load\" , _verbose = False ): \"\"\" alter the value of the load impedance (if side=\"load\") or the source impedance in order to realize a symmetrical balun (ie. primary = secondary) \"\"\" if side == \"load\" : old_z = self . z_ld _through_load = True else : old_z = self . z_src _through_load = False res = minimize ( self . __enforce_symmetrical , - quality_f ( old_z ), args = _through_load , method = \"Nelder-Mead\" , ) new_z = np . real ( old_z ) * ( 1 - 1 j * res . x [ 0 ]) if _verbose : print ( f \"old z_ld: $ { complex ( old_z ) : 5.2f } \" ) print ( f \"new z_ld: $ { complex ( new_z ) : 5.2f } \" ) if _through_load : self . z_ld = complex ( new_z ) else : self . z_src = complex ( new_z )","title":"enforce_symmetrical()"},{"location":"devices/coupler/","text":"Coupler Create a coupler object cost ( self , sol ) return the cost (standard deviation) between the proposed solution and the targeted specifications Source code in passive_auto_design\\devices\\coupler.py def cost ( self , sol ): \"\"\" return the cost (standard deviation) between the proposed solution and the targeted specifications \"\"\" geo = { \"di\" : sol [ 2 ], \"n_turn\" : np . round ( sol [ 1 ]), \"width\" : sol [ 0 ], \"gap\" : sol [ 3 ], } self . transfo . set_primary ( geo ) self . transfo . set_secondary ( geo ) s_p = self . transfo . circuit . s_external [ 0 ] return np . abs ( s_p [ 0 , 0 ]) + np . max ([ 26.7 - ihsr ( s_p [ 1 , 0 ], s_p [ 0 , 1 ]), 0 ]) design ( self , _maxiter = 500 ) design an hybrid coupleur with the targeted specifications (f_targ, z_targ) return an optimization results (res) Source code in passive_auto_design\\devices\\coupler.py def design ( self , _maxiter = 500 ): \"\"\" design an hybrid coupleur with the targeted specifications (f_targ, z_targ) return an optimization results (res) \"\"\" # finding the inner diameter that give the correct inductance minimize_scalar ( self . __cost_est_inductance , bounds = self . bounds [ 2 ]) # finding the path width that give the correct capacitor res_int = minimize_scalar ( self . __cost_est_capacitance , bounds = self . bounds [ 0 ]) geo = self . transfo . prim x_0 = np . array ([ geo [ \"width\" ], geo [ \"n_turn\" ], geo [ \"di\" ], geo [ \"gap\" ]]) if _maxiter == 0 : # just get the first guess res = OptimizeResult () res . x = x_0 res . fun = res_int . fun res . message = \"First Guess\" return res res = minimize ( self . cost , x0 = x_0 ) return res print ( self , res ) print a summary of the solution (res) with a comparison to the boundaries Source code in passive_auto_design\\devices\\coupler.py def print ( self , res ): \"\"\" print a summary of the solution (res) with a comparison to the boundaries \"\"\" sol = res . x * 1e6 bds = np . array ( self . bounds ) * 1e6 print ( f \"Solution funds with remaining error of: { float ( res . fun ) : .2e } \" ) print ( \"Termination message of algorithm: \" + str ( res . message )) print ( \" \\t\\t W (\u00b5m) \\t n \\t di (\u00b5m) \\t G (\u00b5m)\" ) print ( f \"lower bound : \\t { ( bds [ 0 ])[ 0 ] : .2g } \\t { ( self . bounds [ 1 ])[ 0 ] : .2g } \\t\\ { ( bds [ 2 ])[ 0 ] : .3g } \\t { ( bds [ 3 ])[ 0 ] : .2g } \" ) print ( f \"best point : \\t { sol [ 0 ] : .2g } \\t { res . x [ 1 ] : .0g } \\t { sol [ 2 ] : .3g } \\t { sol [ 3 ] : .2g } \" ) print ( f \"upper bound : \\t { ( bds [ 0 ])[ 1 ] : .2g } \\t { ( self . bounds [ 1 ])[ 1 ] : .2g } \\t\\ { ( bds [ 2 ])[ 1 ] : .3g } \\t { ( bds [ 3 ])[ 1 ] : .2g } \" )","title":"Coupler"},{"location":"devices/coupler/#passive_auto_design.devices.coupler.Coupler","text":"Create a coupler object","title":"Coupler"},{"location":"devices/coupler/#passive_auto_design.devices.coupler.Coupler.cost","text":"return the cost (standard deviation) between the proposed solution and the targeted specifications Source code in passive_auto_design\\devices\\coupler.py def cost ( self , sol ): \"\"\" return the cost (standard deviation) between the proposed solution and the targeted specifications \"\"\" geo = { \"di\" : sol [ 2 ], \"n_turn\" : np . round ( sol [ 1 ]), \"width\" : sol [ 0 ], \"gap\" : sol [ 3 ], } self . transfo . set_primary ( geo ) self . transfo . set_secondary ( geo ) s_p = self . transfo . circuit . s_external [ 0 ] return np . abs ( s_p [ 0 , 0 ]) + np . max ([ 26.7 - ihsr ( s_p [ 1 , 0 ], s_p [ 0 , 1 ]), 0 ])","title":"cost()"},{"location":"devices/coupler/#passive_auto_design.devices.coupler.Coupler.design","text":"design an hybrid coupleur with the targeted specifications (f_targ, z_targ) return an optimization results (res) Source code in passive_auto_design\\devices\\coupler.py def design ( self , _maxiter = 500 ): \"\"\" design an hybrid coupleur with the targeted specifications (f_targ, z_targ) return an optimization results (res) \"\"\" # finding the inner diameter that give the correct inductance minimize_scalar ( self . __cost_est_inductance , bounds = self . bounds [ 2 ]) # finding the path width that give the correct capacitor res_int = minimize_scalar ( self . __cost_est_capacitance , bounds = self . bounds [ 0 ]) geo = self . transfo . prim x_0 = np . array ([ geo [ \"width\" ], geo [ \"n_turn\" ], geo [ \"di\" ], geo [ \"gap\" ]]) if _maxiter == 0 : # just get the first guess res = OptimizeResult () res . x = x_0 res . fun = res_int . fun res . message = \"First Guess\" return res res = minimize ( self . cost , x0 = x_0 ) return res","title":"design()"},{"location":"devices/coupler/#passive_auto_design.devices.coupler.Coupler.print","text":"print a summary of the solution (res) with a comparison to the boundaries Source code in passive_auto_design\\devices\\coupler.py def print ( self , res ): \"\"\" print a summary of the solution (res) with a comparison to the boundaries \"\"\" sol = res . x * 1e6 bds = np . array ( self . bounds ) * 1e6 print ( f \"Solution funds with remaining error of: { float ( res . fun ) : .2e } \" ) print ( \"Termination message of algorithm: \" + str ( res . message )) print ( \" \\t\\t W (\u00b5m) \\t n \\t di (\u00b5m) \\t G (\u00b5m)\" ) print ( f \"lower bound : \\t { ( bds [ 0 ])[ 0 ] : .2g } \\t { ( self . bounds [ 1 ])[ 0 ] : .2g } \\t\\ { ( bds [ 2 ])[ 0 ] : .3g } \\t { ( bds [ 3 ])[ 0 ] : .2g } \" ) print ( f \"best point : \\t { sol [ 0 ] : .2g } \\t { res . x [ 1 ] : .0g } \\t { sol [ 2 ] : .3g } \\t { sol [ 3 ] : .2g } \" ) print ( f \"upper bound : \\t { ( bds [ 0 ])[ 1 ] : .2g } \\t { ( self . bounds [ 1 ])[ 1 ] : .2g } \\t\\ { ( bds [ 2 ])[ 1 ] : .3g } \\t { ( bds [ 3 ])[ 1 ] : .2g } \" )","title":"print()"}]}