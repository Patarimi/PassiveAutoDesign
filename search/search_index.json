{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PassiveAutoDesign","text":"<p>Python Script for Fast Design of RF-Passive Components. This script is in an early stage of development. Tested on Windows and Linux.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>The library required are scikit-rf, numpy, scipy, yaml and matplotlib (for plotting results). The required versions can be find in requirements.txt. Install the library using</p> <pre><code>pip install passive-auto-design\n</code></pre> <p>or</p> <pre><code>poetry install\n</code></pre> <p>A demo is given here and the documentation can be found here</p>"},{"location":"#package-structure","title":"Package Structure","text":"<p>The Package is composed of 9 modules:</p> <ul> <li>The substrate.py file which describes the substrate used (or Back End Of Line).</li> <li>The components directory which contains RF-components to be implemented in a susbtrate (Waveguides, Transformers, Coupler...). It also enables rough geometry design/estimation from given rf specifications.</li> <li>The devices module which contains RF-devices. It helps defining the rf-specification of the devices from the given higher-level specification.</li> <li>The special.py file which contains special functions.</li> <li>The space_mapping.py file which help deploy space mapping algorithm.</li> <li>The units module which contains pydantic models to ease the usage of physical dimension. It also contains physical constants.</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>passive_auto_design<ul> <li>components<ul> <li>inductor</li> <li>lumped_element</li> <li>mos</li> <li>transformer</li> <li>waveguide</li> </ul> </li> <li>devices<ul> <li>balun</li> <li>coupler</li> <li>filter</li> <li>taper</li> </ul> </li> <li>space_mapping</li> <li>special</li> <li>substrate</li> <li>system<ul> <li>pll</li> <li>rf_line_up</li> </ul> </li> <li>units<ul> <li>constants</li> <li>converters</li> <li>noise</li> <li>physical_dimension</li> <li>time</li> <li>unit</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/passive_auto_design/","title":"passive_auto_design","text":""},{"location":"reference/passive_auto_design/space_mapping/","title":"space_mapping","text":"<p>Implementation of an aggressive space mapping algorithm for RF-design</p>"},{"location":"reference/passive_auto_design/space_mapping/#passive_auto_design.space_mapping.cost_calc","title":"<code>cost_calc(perf_list, goal_list, weight_list=None)</code>  <code>cached</code>","text":"<p>return the normalize standard deviation between the perf_list and the goal_list</p> <p>Parameters:</p> Name Type Description Default <code>perf_list</code> <code>tuple of float</code> <p>list of the performances achieved.</p> required <code>goal_list</code> <code>tuple of float</code> <p>list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval.</p> required <code>weight_list</code> <code>tuple of float, optional</code> <p>weightning of the goals. If set to None, all the weight are set to one.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cost</code> <code>float</code> <p>cost value</p> Source code in <code>passive_auto_design\\space_mapping.py</code> <pre><code>@functools.lru_cache()\ndef cost_calc(perf_list, goal_list, weight_list=None):\n\"\"\"\n    return the normalize standard deviation between the perf_list and the goal_list\n\n    Parameters\n    ----------\n    perf_list : tuple of float\n        list of the performances achieved.\n    goal_list : tuple of float\n        list of the goal to be achieved. If one value is given, the goal is a point. If two, the goal is an interval.\n    weight_list : tuple of float, optional\n        weightning of the goals. If set to None, all the weight are set to one.\n\n    Returns\n    -------\n    cost : float\n        cost value\n\n    \"\"\"\n    if weight_list is None:\n        weight_list = [1] * len(goal_list)\n    cost = 0\n    for itern, goal in enumerate(goal_list):\n        perf = perf_list[itern]\n        goal = goal_list[itern]\n        if isinstance(goal, tuple):\n            err_min = max((perf - goal[0]) / (goal[0] if goal[0] != 0 else 1), 0)\n            err_max = max((goal[1] - perf) / (goal[1] if goal[1] != 0 else 1), 0)\n            err = err_min + err_max\n        else:\n            err = (perf - goal) / (goal if goal != 0 else 1)\n        cost += weight_list[itern] * err**2\n    return cost\n</code></pre>"},{"location":"reference/passive_auto_design/space_mapping/#passive_auto_design.space_mapping.space_map","title":"<code>space_map(coarse_model, dim0, fine_model, par0, goal, maxiter=5)</code>","text":"<p>Optimization function for space mapping algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>coarse_model</code> <code>fun</code> <p>function evaluating the coarse model goals for a set of dimensions (dim) and parameters (par)</p> required <code>dim0</code> <code>dict</code> <p>initial dimensions of the component</p> required <code>fine_model</code> <code>fun</code> <p>function evaluating the fine model goals for a set of dimensions (dim)</p> required <code>par0</code> <code>dict</code> <p>initial parameters of the component coarse model</p> required <code>goal</code> <code>dict</code> <p>set of goal targeted by the algorithm</p> required <code>maxiter</code> <code>int, optional</code> <p>maximal number of iteration. The default is 5.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>dim</code> <code>dict</code> <p>final dimension of the component.</p> <code>par</code> <code>dict</code> <p>final parameters of the component model.</p> <code>fine_mod</code> <code>dict</code> <p>achieved goal.</p> Source code in <code>passive_auto_design\\space_mapping.py</code> <pre><code>def space_map(coarse_model, dim0, fine_model, par0, goal, maxiter=5):\n\"\"\"\n    Optimization function for space mapping algorithm.\n\n    Parameters\n    ----------\n    coarse_model : fun\n        function evaluating the coarse model goals\n        for a set of dimensions (dim) and parameters (par)\n    dim0 : dict\n        initial dimensions of the component\n    fine_model : fun\n        function evaluating the fine model goals\n        for a set of dimensions (dim)\n    par0 : dict\n        initial parameters of the component coarse model\n    goal : dict\n        set of goal targeted by the algorithm\n    maxiter : int, optional\n        maximal number of iteration. The default is 5.\n\n    Returns\n    -------\n    dim : dict\n        final dimension of the component.\n    par : dict\n        final parameters of the component model.\n    fine_mod : dict\n        achieved goal.\n\n    \"\"\"\n    dim = dim0\n    par = par0\n    achieved_goal = goal\n    for i in range(maxiter):\n        # evaluate exact value using fine model\n        achieved_goal = fine_model(dim)\n        # alter coarse model parameters to better match fine model results\n        res = minimize(\n            __refresh_coarse,\n            __totuple(par),\n            method=\"L-BFGS-B\",\n            args=(par0.keys(), dim, coarse_model, achieved_goal),\n        )\n        par = __todict(par0.keys(), res.x)\n        # find best solution according to coarse model\n        res = minimize(\n            __cost_coarse,\n            __totuple(dim),\n            method=\"Powell\",\n            args=(dim0.keys(), par, coarse_model, goal),\n        )\n        dim = __todict(dim0.keys(), res.x)\n    return dim, par, achieved_goal\n</code></pre>"},{"location":"reference/passive_auto_design/special/","title":"special","text":"<p>Define constants and function dedicated to RF-conception</p>"},{"location":"reference/passive_auto_design/special/#passive_auto_design.special.gamma","title":"<code>gamma(_z_load, _z0=50)</code>","text":"<p>return the reflexion coefficient of an interface between two impedances.</p> Source code in <code>passive_auto_design\\special.py</code> <pre><code>def gamma(_z_load: PhysicalDimension, _z0: PhysicalDimension = 50):\n\"\"\"\n    return the reflexion coefficient of an interface between two impedances.\n    \"\"\"\n    v = np.array((_z0 - _z_load) / (_z0 + _z_load))\n    return PhysicalDimension(value=v, scale=\"lin\", unit=\"\")\n</code></pre>"},{"location":"reference/passive_auto_design/special/#passive_auto_design.special.ihsr","title":"<code>ihsr(_s31, _s21)</code>","text":"<p>Return the IHSR (Ideal Hybrid Splitting Ratio) for the given gains</p> Source code in <code>passive_auto_design\\special.py</code> <pre><code>def ihsr(_s31, _s21):\n\"\"\"\n    Return the IHSR (Ideal Hybrid Splitting Ratio) for the given gains\n    \"\"\"\n    if _s21 == 1j * _s31 or _s21 == -1j * _s31:\n        return np.inf\n    ihsr_log = 10 * np.log10(np.abs((_s21 - 1j * _s31) / (_s21 + 1j * _s31)))\n    return -np.minimum(ihsr_log, -ihsr_log)\n</code></pre>"},{"location":"reference/passive_auto_design/special/#passive_auto_design.special.quality_f","title":"<code>quality_f(_z)</code>","text":"<p>return the quality factor of a components</p> Source code in <code>passive_auto_design\\special.py</code> <pre><code>def quality_f(_z):\n\"\"\"\n    return the quality factor of a components\n    \"\"\"\n    return np.imag(_z) / np.real(_z)\n</code></pre>"},{"location":"reference/passive_auto_design/special/#passive_auto_design.special.reflexion_coef","title":"<code>reflexion_coef(_z_steps, _phi_step)</code>","text":"<p>return the coefficient reflexion of a given sequence of transmission lines with the given_z_steps profile and equal length of _phi_steps degrees</p> Source code in <code>passive_auto_design\\special.py</code> <pre><code>def reflexion_coef(_z_steps: PhysicalDimension, _phi_step: float):\n\"\"\"\n    return the coefficient reflexion of a given sequence of transmission lines\n    with the given_z_steps profile and equal length of _phi_steps degrees\n    \"\"\"\n    n_step = _z_steps.shape[0]\n\n    z_tot = _z_steps[-1:]\n    for i in range(n_step):\n        z_0 = _z_steps[n_step - i - 1]\n        z_tot = (\n            z_0\n            * (z_tot + 1j * z_0 * np.tan(_phi_step))\n            / (z_0 + 1j * z_tot * np.tan(_phi_step))\n        )\n    return gamma(_z_steps[0], z_tot)\n</code></pre>"},{"location":"reference/passive_auto_design/special/#passive_auto_design.special.std_dev","title":"<code>std_dev(measured, targeted)</code>","text":"<p>return the standard deviation between an array_like of results and their references.</p> Source code in <code>passive_auto_design\\special.py</code> <pre><code>def std_dev(measured, targeted):\n\"\"\"\n    return the standard deviation between an array_like of results and their references.\n    \"\"\"\n    tmp = np.array(np.abs(gamma(measured, targeted).value) ** 2)\n    return np.sqrt(np.sum(tmp))\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/","title":"substrate","text":"<p>Define all the object use to describe the substrate in which the structures are created.</p>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Dielectric","title":"<code>Dielectric</code>","text":"<p>define the dielectric property of a layer</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>class Dielectric:\n\"\"\"\n    define the dielectric property of a layer\n    \"\"\"\n\n    def __init__(self, _epsilon, _tan_d=0.0, _roughness=0.0):\n        self.epsilon = _epsilon\n        self.tan_d = _tan_d\n        self.roughness = _roughness\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Layer","title":"<code>Layer</code>","text":"<p>define a layer for a substrate</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>class Layer:\n\"\"\"\n    define a layer for a substrate\n    \"\"\"\n\n    def __init__(self, _name, _height, _metal, _dielectric):\n        self.name = _name\n        self.metal = _metal\n        self.width = {\"min\": 1e-3, \"max\": 1e-3}\n        self.gap = 1e-3\n        self.dielectric = _dielectric\n        self.height = _height\n\n    def set_rules(self, _metal_w_min, _metal_w_max, _metal_gap_min):\n\"\"\"\n        Set the technological rules of the layer\n        minimal and maximal width, and minimal gap\n        \"\"\"\n        self.width = {\"min\": _metal_w_min, \"max\": _metal_w_max}\n        self.gap = _metal_gap_min\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Layer.set_rules","title":"<code>set_rules(_metal_w_min, _metal_w_max, _metal_gap_min)</code>","text":"<p>Set the technological rules of the layer minimal and maximal width, and minimal gap</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>def set_rules(self, _metal_w_min, _metal_w_max, _metal_gap_min):\n\"\"\"\n    Set the technological rules of the layer\n    minimal and maximal width, and minimal gap\n    \"\"\"\n    self.width = {\"min\": _metal_w_min, \"max\": _metal_w_max}\n    self.gap = _metal_gap_min\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Metal","title":"<code>Metal</code>","text":"<p>define the metal property of a layer</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>class Metal:\n\"\"\"\n    define the metal property of a layer\n    \"\"\"\n\n    def __init__(self, _rho, _roughness=0.0):\n        self.rho = _rho\n        self.roughness = _roughness\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Substrate","title":"<code>Substrate</code>","text":"<p>contain all informations about a substrate</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>class Substrate:\n\"\"\"\n    contain all informations about a substrate\n    \"\"\"\n\n    def __init__(self, _path=\"\"):\n        if _path != \"\":\n            self.load(_path)\n        else:\n            self.sub = list()\n\n    def add_layer(self, _layer):\n\"\"\"\n        add a layer on top of the last layer\n        \"\"\"\n        self.sub.append(_layer)\n\n    def get_index_of(self, _layer_name):\n\"\"\"\n        return the index of the first layer with the _layer_name name\n        \"\"\"\n        index = -1\n        for layer in self.sub:\n            index = index + 1\n            if layer.name == _layer_name:\n                return index\n        raise ValueError(f\"No layer find with name: {_layer_name}\")\n\n    def dump(self, _path):\n\"\"\"\n        save the substrate as an yaml file\n        \"\"\"\n        save_dir = _path.rsplit(\"/\", 1)\n        if len(save_dir) &lt; 2:\n            raise ValueError(\"incorrect path\")\n        if len(save_dir) == 2:\n            os.makedirs(save_dir[0], exist_ok=True)\n        with open(_path, \"w+\") as file:\n            yaml.dump(self.sub, file)\n\n    def load(self, _path):\n\"\"\"\n        load a yaml file to configure the substrate\n        \"\"\"\n        with open(_path) as file:\n            self.sub = yaml.full_load(file)\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Substrate.add_layer","title":"<code>add_layer(_layer)</code>","text":"<p>add a layer on top of the last layer</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>def add_layer(self, _layer):\n\"\"\"\n    add a layer on top of the last layer\n    \"\"\"\n    self.sub.append(_layer)\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Substrate.dump","title":"<code>dump(_path)</code>","text":"<p>save the substrate as an yaml file</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>def dump(self, _path):\n\"\"\"\n    save the substrate as an yaml file\n    \"\"\"\n    save_dir = _path.rsplit(\"/\", 1)\n    if len(save_dir) &lt; 2:\n        raise ValueError(\"incorrect path\")\n    if len(save_dir) == 2:\n        os.makedirs(save_dir[0], exist_ok=True)\n    with open(_path, \"w+\") as file:\n        yaml.dump(self.sub, file)\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Substrate.get_index_of","title":"<code>get_index_of(_layer_name)</code>","text":"<p>return the index of the first layer with the _layer_name name</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>def get_index_of(self, _layer_name):\n\"\"\"\n    return the index of the first layer with the _layer_name name\n    \"\"\"\n    index = -1\n    for layer in self.sub:\n        index = index + 1\n        if layer.name == _layer_name:\n            return index\n    raise ValueError(f\"No layer find with name: {_layer_name}\")\n</code></pre>"},{"location":"reference/passive_auto_design/substrate/#passive_auto_design.substrate.Substrate.load","title":"<code>load(_path)</code>","text":"<p>load a yaml file to configure the substrate</p> Source code in <code>passive_auto_design\\substrate.py</code> <pre><code>def load(self, _path):\n\"\"\"\n    load a yaml file to configure the substrate\n    \"\"\"\n    with open(_path) as file:\n        self.sub = yaml.full_load(file)\n</code></pre>"},{"location":"reference/passive_auto_design/components/","title":"components","text":"<p>Components are elements that define a link between geometrical dimensionsand electrical behavior using physical parameter. For example, Inductor create a link between the inner and outer diameter and its self-inductance.</p>"},{"location":"reference/passive_auto_design/components/inductor/","title":"inductor","text":""},{"location":"reference/passive_auto_design/components/inductor/#passive_auto_design.components.inductor.Inductor","title":"<code>Inductor</code>","text":"<p>         Bases: <code>LumpedElement</code></p> <p>class describing a inductor behavior using wheeler formula for ic</p> Source code in <code>passive_auto_design\\components\\inductor.py</code> <pre><code>class Inductor(LumpedElement):\n\"\"\"\n    class describing a inductor behavior using wheeler formula for ic\n    \"\"\"\n\n    def __init__(self, d_i=100e-6, n_turn=1, width=3e-6, gap=1e-6, k_1=2.25, k_2=3.55):\n        param = {\"d_i\": d_i, \"n_turn\": n_turn, \"width\": width, \"gap\": gap}\n        const = {\"k_1\": k_1, \"k_2\": k_2}\n        LumpedElement.__init__(self, dim=param, const=const)\n\n    def __str__(self):\n        return Ind(self.model[\"ind\"])\n\n    def get_model(self):\n        n = self.dim[\"n_turn\"]\n        outer_diam = (\n            self.dim[\"d_i\"] + 2 * n * self.dim[\"width\"] + 2 * (n - 1) * self.dim[\"gap\"]\n        )\n        self.dim[\"d_o\"] = outer_diam\n        rho = (self.dim[\"d_i\"] + outer_diam) / 2\n        density = (outer_diam - self.dim[\"d_i\"]) / (outer_diam + self.dim[\"d_i\"])\n        ind = self.const[\"k_1\"] * u0 * n**2 * rho / (1 + self.const[\"k_2\"] * density)\n        return {\"ind\": ind}\n\n    def draw(self, file: FilePath):\n        ly = db.Layout()\n\n        # sets the database unit to 1 nm\n        ly.dbu = 0.001\n\n        # adds a single top cell\n        top_cell = ly.create_cell(\"inductor\")\n\n        # creates a new layer (layer number 1, datatype 0)\n        layer1 = ly.layer(1, 0)\n        d_i = 5.0\n        pts = [\n            db.DPoint(0, -d_i / 2),\n            db.DPoint(d_i / 2, -d_i / 2),\n            db.DPoint(d_i / 2, d_i / 2),\n            db.DPoint(0, d_i / 2),\n        ]\n        rect = db.DPath(pts, 2.0)\n        top_cell.shapes(layer1).insert(rect)\n\n        ly.write(file)\n</code></pre>"},{"location":"reference/passive_auto_design/components/lumped_element/","title":"lumped_element","text":""},{"location":"reference/passive_auto_design/components/lumped_element/#passive_auto_design.components.lumped_element.Capacitor","title":"<code>Capacitor</code>","text":"<p>         Bases: <code>LumpedElement</code></p> <p>class describing a capacitor behavior - dimension:     - area: area of plate     - dist: distance between plates - constant:     - eps_r: relative permittivity of isolator - behavioral:     - cap: capacitor</p> Source code in <code>passive_auto_design\\components\\lumped_element.py</code> <pre><code>class Capacitor(LumpedElement):\n\"\"\"\n    class describing a capacitor behavior\n    - dimension:\n        - area: area of plate\n        - dist: distance between plates\n    - constant:\n        - eps_r: relative permittivity of isolator\n    - behavioral:\n        - cap: capacitor\n    \"\"\"\n\n    def __init__(self, area=1e-6, dist=1e-3, eps_r=1):\n        dim = {\"area\": area, \"dist\": dist}\n        const = {\"eps_r\": eps_r}\n        LumpedElement.__init__(self, dim=dim, const=const)\n\n    def __str__(self):\n        return Cap(self.model[\"cap\"])\n\n    def get_model(self):\n        return {\"cap\": eps0 * self.const[\"eps_r\"] * self.dim[\"area\"] / self.dim[\"dist\"]}\n</code></pre>"},{"location":"reference/passive_auto_design/components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement","title":"<code>LumpedElement</code>","text":"<p>         Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>class of standard lumped element, to be inherited by all lumped elements</p> Source code in <code>passive_auto_design\\components\\lumped_element.py</code> <pre><code>class LumpedElement(BaseModel, ABC):\n\"\"\"\n    class of standard lumped element, to be inherited by all lumped elements\n    \"\"\"\n\n    dim: Dict[str, float]\n    const: Dict[str, float]\n    model: Dict[str, float] = {}\n\n    def __init__(self, dim, const, **data):\n        BaseModel.__init__(self, dim=dim, const=const, **data)\n        self.model = self.get_model()\n\n    # TODO enable multiple x_keys\n    def set_model_with_dim(self, target_model: Dict[str, float], dim_key: str) -&gt; float:\n\"\"\"\n        set the value of the dim_key to achieve the target model\n        \"\"\"\n        res = minimize_scalar(self.__cost, args=(dim_key, target_model))\n        self.model = self.get_model()\n        return res.x\n\n    def __cost(\n        self, x_value: float, x_key: str, target_model: Dict[str, float]\n    ) -&gt; float:\n        if x_key in self.dim:\n            self.dim[x_key] = x_value\n        if x_key in self.const:\n            self.const[x_key] = x_value\n        tmp_model = self.get_model()\n        cost = 0\n        for key in target_model.keys():\n            cost += (target_model[key] - tmp_model[key]) ** 2 / (\n                target_model[key] + tmp_model[key]\n            ) ** 2\n        return cost\n\n    @abstractmethod\n    def get_model(self):\n\"\"\"\n        Definition of the behavioral equation of the lumped element.\n        Returns\n        -------\n        Dict[str, float]: list of the electrical parameter of the lumped element model\n        \"\"\"\n</code></pre>"},{"location":"reference/passive_auto_design/components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement.get_model","title":"<code>get_model()</code>  <code>abstractmethod</code>","text":"<p>Definition of the behavioral equation of the lumped element.</p> <p>Returns:</p> Type Description <code>Dict[str, float]</code> Source code in <code>passive_auto_design\\components\\lumped_element.py</code> <pre><code>@abstractmethod\ndef get_model(self):\n\"\"\"\n    Definition of the behavioral equation of the lumped element.\n    Returns\n    -------\n    Dict[str, float]: list of the electrical parameter of the lumped element model\n    \"\"\"\n</code></pre>"},{"location":"reference/passive_auto_design/components/lumped_element/#passive_auto_design.components.lumped_element.LumpedElement.set_model_with_dim","title":"<code>set_model_with_dim(target_model, dim_key)</code>","text":"<p>set the value of the dim_key to achieve the target model</p> Source code in <code>passive_auto_design\\components\\lumped_element.py</code> <pre><code>def set_model_with_dim(self, target_model: Dict[str, float], dim_key: str) -&gt; float:\n\"\"\"\n    set the value of the dim_key to achieve the target model\n    \"\"\"\n    res = minimize_scalar(self.__cost, args=(dim_key, target_model))\n    self.model = self.get_model()\n    return res.x\n</code></pre>"},{"location":"reference/passive_auto_design/components/lumped_element/#passive_auto_design.components.lumped_element.Resistor","title":"<code>Resistor</code>","text":"<p>         Bases: <code>LumpedElement</code></p> <p>class describing a resistor behavior</p> Source code in <code>passive_auto_design\\components\\lumped_element.py</code> <pre><code>class Resistor(LumpedElement):\n\"\"\"\n    class describing a resistor behavior\n    \"\"\"\n\n    def __init__(self, section=1e-3, length=1, rho=1e-15):\n        param = {\"section\": section, \"length\": length}\n        const = {\"rho\": rho}\n        LumpedElement.__init__(self, dim=param, const=const)\n\n    def __str__(self):\n        return Res(self.model[\"res\"])\n\n    def get_model(self):\n        return {\n            \"res\": max(\n                [self.const[\"rho\"] * self.dim[\"length\"] / self.dim[\"section\"], 0.0]\n            )\n        }\n</code></pre>"},{"location":"reference/passive_auto_design/components/mos/","title":"mos","text":"<p>[WIP]</p>"},{"location":"reference/passive_auto_design/components/mos/#passive_auto_design.components.mos.I_d","title":"<code>I_d(width, length, psi_ss, psi_sd, v_g)</code>","text":"<p>drain current</p> Source code in <code>passive_auto_design\\components\\mos.py</code> <pre><code>def I_d(width: float, length: float, psi_ss, psi_sd, v_g):\n\"\"\"\n    drain current\n    \"\"\"\n    beta = mu_Cox * width / length\n    return beta * (f_psi(psi_sd, v_g) - f_psi(psi_ss, v_g))\n</code></pre>"},{"location":"reference/passive_auto_design/components/mos/#passive_auto_design.components.mos.V_non_eq","title":"<code>V_non_eq(psi_s, V_g)</code>","text":"<p>non-equilibrium voltage</p> Source code in <code>passive_auto_design\\components\\mos.py</code> <pre><code>def V_non_eq(psi_s: float, V_g: float):\n\"\"\"\n    non-equilibrium voltage\n    \"\"\"\n    ga = gamma(mu_Cox, N)\n    n_i = 1e15\n    phib = phi_b(N, n_i)\n    return -U_t * np.log((((V_g - psi_s) / ga) ** 2 - psi_s) / U_t) + psi_s - 2 * phib\n</code></pre>"},{"location":"reference/passive_auto_design/components/mos/#passive_auto_design.components.mos.f_psi","title":"<code>f_psi(psi, V_g)</code>","text":"<p>function that link bulk potential and drain current</p> Source code in <code>passive_auto_design\\components\\mos.py</code> <pre><code>def f_psi(psi: float, V_g: float):\n\"\"\"\n    function that link bulk potential and drain current\n    \"\"\"\n    ga = gamma(mu_Cox, N)\n    return (\n        -0.5 * psi**2\n        - (2 / 3) * ga * (psi**1.5)\n        + (V_g + U_t) * psi\n        + ga * U_t * (psi**0.5)\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/components/mos/#passive_auto_design.components.mos.gamma","title":"<code>gamma(c_ox, N_atom)</code>","text":"<p>body effect parameter</p> Source code in <code>passive_auto_design\\components\\mos.py</code> <pre><code>def gamma(c_ox: float, N_atom: float):\n\"\"\"\n    body effect parameter\n    \"\"\"\n    eps_si = 11.5 * eps0\n    return 50 * np.sqrt(2 * q * eps_si * N_atom) / c_ox\n</code></pre>"},{"location":"reference/passive_auto_design/components/mos/#passive_auto_design.components.mos.phi_b","title":"<code>phi_b(N, n_i)</code>","text":"<p>bulk potential</p> Source code in <code>passive_auto_design\\components\\mos.py</code> <pre><code>def phi_b(N: float, n_i: float):\n\"\"\"\n    bulk potential\n    \"\"\"\n    return U_t * np.log(N / n_i)\n</code></pre>"},{"location":"reference/passive_auto_design/components/transformer/","title":"transformer","text":""},{"location":"reference/passive_auto_design/components/transformer/#passive_auto_design.components.transformer.Transformer","title":"<code>Transformer</code>","text":"<p>         Bases: <code>lmp.LumpedElement</code></p> <p>Create a transformer object with the specified Inductors primary &amp; secondary and calculate the associated electrical model if sym=True, Create a symmetrical transformer (secondary is ignored and assume egal to primary)</p> Source code in <code>passive_auto_design\\components\\transformer.py</code> <pre><code>class Transformer(lmp.LumpedElement):\n\"\"\"\n    Create a transformer object with the specified Inductors primary &amp; secondary\n    and calculate the associated electrical model\n    if sym=True, Create a symmetrical transformer (secondary is ignored and assume egal to primary)\n    \"\"\"\n\n    sym: bool\n\n    def __init__(\n        self,\n        primary: Inductor,\n        secondary=None,\n        rho=0.0,\n        eps_r=0.0,\n        h_mut=0.0,\n        h_gnd=0.0,\n        sym=False,\n    ):\n        const = {\n            \"eps_r\": eps_r,\n            \"rho\": rho,\n        }\n        dim = {\n            \"h_mut\": h_mut,\n            \"h_gnd\": h_gnd,\n        }\n        for key in primary.dim.keys():\n            dim[\"lp.\" + key] = primary.dim[key]\n            dim[\"ls.\" + key] = primary.dim[key] if sym else secondary.dim[key]\n        lmp.LumpedElement.__init__(self, dim=dim, const=const, sym=sym)\n\n    def get_model(self):\n        primary = Inductor(\n            self.dim[\"lp.d_i\"],\n            self.dim[\"lp.n_turn\"],\n            self.dim[\"lp.width\"],\n            self.dim[\"lp.gap\"],\n        )\n        self.model[\"lp\"] = primary.model[\"ind\"]\n        if self.sym:\n            self.model[\"ls\"] = primary.model[\"ind\"]\n        else:\n            secondary = Inductor(\n                self.dim[\"ls.d_i\"],\n                self.dim[\"ls.n_turn\"],\n                self.dim[\"ls.width\"],\n                self.dim[\"ls.gap\"],\n            )\n            self.model[\"ls\"] = secondary.model[\"ind\"]\n        self.model[\"rp\"] = self.r_geo(True)\n        self.model[\"rs\"] = self.r_geo(False)\n        self.model[\"cm\"] = self.cc_geo(True)\n        self.model[\"cg\"] = self.cc_geo(False)\n        self.model[\"k\"] = self.k_geo()\n        return self.model\n\n    def cc_geo(self, _mutual=True):\n\"\"\"\n        return the value of the distributed capacitance of the described transformer\n        if _mutual, return the capacitance between primary and secondary\n        else, return the capacitance to the ground plane\n        \"\"\"\n        dim = self.dim\n        if _mutual:\n            dist = float(self.dim[\"h_mut\"])\n            d_i = np.max([dim[\"lp.d_i\"], dim[\"ls.d_i\"]])\n            d_o = np.min(\n                [\n                    d_i + dim[\"lp.n_turn\"] * dim[\"lp.width\"],\n                    d_i + dim[\"ls.n_turn\"] * dim[\"ls.width\"],\n                ]\n            )\n        else:\n            dist = float(self.dim[\"h_gnd\"])\n            d_i = np.min([dim[\"ls.d_i\"], dim[\"lp.d_i\"]])\n            d_o = np.max(\n                [\n                    d_i + dim[\"lp.n_turn\"] * dim[\"lp.width\"],\n                    d_i + dim[\"ls.n_turn\"] * dim[\"ls.width\"],\n                ]\n            )\n        eps_r = float(self.const[\"eps_r\"])\n        area = 4 * (d_o**2 - d_i**2) * (1 + 2 * np.sqrt(2))\n        cap = lmp.Capacitor(area, dist, eps_r)\n        return np.abs(cap.model[\"cap\"])\n\n    def r_geo(self, _of_primary=True):\n\"\"\"\n        return the value of the resistance of the described transformer\n        \"\"\"\n        geo = \"lp.\" if _of_primary else \"lp.\"\n        rho = self.const[\"rho\"]\n        n_t = self.dim[geo + \"n_turn\"]\n        l_tot = (\n            8\n            * np.tan(np.pi / 8)\n            * n_t\n            * (\n                self.dim[geo + \"d_i\"]\n                + self.dim[geo + \"width\"]\n                + (n_t - 1) * (self.dim[geo + \"width\"] + self.dim[geo + \"gap\"])\n            )\n        )\n        r_dc = lmp.Resistor(self.dim[geo + \"width\"], l_tot, rho)\n        return r_dc.model[\"res\"]\n\n    def k_geo(self):\n\"\"\"\n        return the value of the coupling between the two inductors.\n\n        \"\"\"\n        dim = self.dim\n        c1 = dim[\"lp.width\"] * dim[\"lp.n_turn\"] + dim[\"lp.gap\"] * (dim[\"lp.n_turn\"] - 1)\n        d1 = dim[\"lp.d_i\"]\n        c2 = dim[\"ls.width\"] * dim[\"ls.n_turn\"] + dim[\"ls.gap\"] * (dim[\"ls.n_turn\"] - 1)\n        d2 = dim[\"ls.d_i\"]\n        return (\n            0.99\n            * (np.max([d1, d2]) - np.min([c1 + d1, c2 + d2]))\n            / (np.max([c1 + d1, c2 + d2]) - np.min([d1, d2]))\n        )\n</code></pre>"},{"location":"reference/passive_auto_design/components/transformer/#passive_auto_design.components.transformer.Transformer.cc_geo","title":"<code>cc_geo(_mutual=True)</code>","text":"<p>return the value of the distributed capacitance of the described transformer if _mutual, return the capacitance between primary and secondary else, return the capacitance to the ground plane</p> Source code in <code>passive_auto_design\\components\\transformer.py</code> <pre><code>def cc_geo(self, _mutual=True):\n\"\"\"\n    return the value of the distributed capacitance of the described transformer\n    if _mutual, return the capacitance between primary and secondary\n    else, return the capacitance to the ground plane\n    \"\"\"\n    dim = self.dim\n    if _mutual:\n        dist = float(self.dim[\"h_mut\"])\n        d_i = np.max([dim[\"lp.d_i\"], dim[\"ls.d_i\"]])\n        d_o = np.min(\n            [\n                d_i + dim[\"lp.n_turn\"] * dim[\"lp.width\"],\n                d_i + dim[\"ls.n_turn\"] * dim[\"ls.width\"],\n            ]\n        )\n    else:\n        dist = float(self.dim[\"h_gnd\"])\n        d_i = np.min([dim[\"ls.d_i\"], dim[\"lp.d_i\"]])\n        d_o = np.max(\n            [\n                d_i + dim[\"lp.n_turn\"] * dim[\"lp.width\"],\n                d_i + dim[\"ls.n_turn\"] * dim[\"ls.width\"],\n            ]\n        )\n    eps_r = float(self.const[\"eps_r\"])\n    area = 4 * (d_o**2 - d_i**2) * (1 + 2 * np.sqrt(2))\n    cap = lmp.Capacitor(area, dist, eps_r)\n    return np.abs(cap.model[\"cap\"])\n</code></pre>"},{"location":"reference/passive_auto_design/components/transformer/#passive_auto_design.components.transformer.Transformer.k_geo","title":"<code>k_geo()</code>","text":"<p>return the value of the coupling between the two inductors.</p> Source code in <code>passive_auto_design\\components\\transformer.py</code> <pre><code>def k_geo(self):\n\"\"\"\n    return the value of the coupling between the two inductors.\n\n    \"\"\"\n    dim = self.dim\n    c1 = dim[\"lp.width\"] * dim[\"lp.n_turn\"] + dim[\"lp.gap\"] * (dim[\"lp.n_turn\"] - 1)\n    d1 = dim[\"lp.d_i\"]\n    c2 = dim[\"ls.width\"] * dim[\"ls.n_turn\"] + dim[\"ls.gap\"] * (dim[\"ls.n_turn\"] - 1)\n    d2 = dim[\"ls.d_i\"]\n    return (\n        0.99\n        * (np.max([d1, d2]) - np.min([c1 + d1, c2 + d2]))\n        / (np.max([c1 + d1, c2 + d2]) - np.min([d1, d2]))\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/components/transformer/#passive_auto_design.components.transformer.Transformer.r_geo","title":"<code>r_geo(_of_primary=True)</code>","text":"<p>return the value of the resistance of the described transformer</p> Source code in <code>passive_auto_design\\components\\transformer.py</code> <pre><code>def r_geo(self, _of_primary=True):\n\"\"\"\n    return the value of the resistance of the described transformer\n    \"\"\"\n    geo = \"lp.\" if _of_primary else \"lp.\"\n    rho = self.const[\"rho\"]\n    n_t = self.dim[geo + \"n_turn\"]\n    l_tot = (\n        8\n        * np.tan(np.pi / 8)\n        * n_t\n        * (\n            self.dim[geo + \"d_i\"]\n            + self.dim[geo + \"width\"]\n            + (n_t - 1) * (self.dim[geo + \"width\"] + self.dim[geo + \"gap\"])\n        )\n    )\n    r_dc = lmp.Resistor(self.dim[geo + \"width\"], l_tot, rho)\n    return r_dc.model[\"res\"]\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/","title":"waveguide","text":""},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.AF_SIW","title":"<code>AF_SIW</code>","text":"<p>         Bases: <code>Waveguide</code></p> <p>Create an AF-SIW object with a given geometry</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>class AF_SIW(Waveguide):\n\"\"\"\n    Create an AF-SIW object with a given geometry\n    \"\"\"\n\n    def __init__(self, _metal, _diel, _height, _slab):\n        self.slab = _slab\n        Waveguide.__init__(self, _metal, _diel, _height)\n        self.width = 0.0\n        self.first_cut_off = 0.0\n\n    @property\n    def width(self) -&gt; float:\n        if self.f_c &gt; 0:\n            slb = self.slab\n            sqr_eps = np.sqrt(self.diel.epsilon)\n            tan = np.tan(2 * slb * np.pi * self.f_c / c0) * sqr_eps\n            self._w = 2 * slb + np.arctan(1 / tan) * c0 / (sqr_eps * np.pi * self.f_c)\n        return self._w\n\n    @width.setter\n    def width(self, _width):\n\"\"\"\n        set the width of the wave-guide and update the cut-off frequency\n        \"\"\"\n        self._w = _width\n\n    @property\n    def slab(self) -&gt; float:\n        return self._slab\n\n    @slab.setter\n    def slab(self, _s: float):\n        if _s &lt;= 0:\n            raise ValueError(\"Slab must be above zero. Please use Waveguide class\")\n        self._slab = _s\n\n    @property\n    def first_cut_off(self) -&gt; float:\n        if self.width &gt; 0:\n            self.f_c = self.f_cut_off(1, 0)\n        return self.f_c\n\n    @first_cut_off.setter\n    def first_cut_off(self, _fc):\n\"\"\"\n        set the cut-off frequency of the wave-guide and update the width\n        \"\"\"\n        self.f_c = _fc\n\n    def f_cut_off(self, _m=1, _n=0) -&gt; float:\n\"\"\"\n        return the value of the cut-off frequency of the TEM mode _m, _n\n        \"\"\"\n        if _n &gt; 0:\n            raise ValueError(\"Value of _n greater than 0 are not supported\")\n        if _m % 2 == 1:\n            res = minimize_scalar(self.__odd_fc)\n        else:\n            f_c = self.f_c\n            res = minimize_scalar(\n                self.__even_fc, bounds=(1.5 * f_c, 5 * f_c), method=\"bounded\"\n            )\n        return res.x\n\n    def __odd_fc(self, _fc):\n        if _fc &lt;= 0:  # frequency must be strictly positive\n            return 1e12\n        slb = self._slab\n        wth = self._w\n        sqr_eps = np.sqrt(self.diel.epsilon)\n        return np.abs(\n            sqr_eps * np.tan(2 * np.pi * _fc * slb / c0)\n            - 1 / np.tan(sqr_eps * np.pi * _fc * (wth - 2 * slb) / c0)\n        )\n\n    def __even_fc(self, _fc):\n        slb = self._slab\n        wth = self._w\n        sqr_eps = np.sqrt(self.diel.epsilon)\n        return np.abs(\n            sqr_eps * np.tan(2 * np.pi * _fc * slb / c0)\n            + np.tan(sqr_eps * np.pi * _fc * (wth - 2 * slb) / c0)\n        )\n\n    def calc_a_d(self, _freq):\n        return 0\n\n    def calc_ksr(self, _freq):\n        rho = self.metal.rho\n        skin_d = 1 / np.sqrt(rho * np.pi * _freq * u0)\n        rough = self.metal.roughness\n        return 2 * np.arctan(1.4 * (rough / skin_d) ** 2) / np.pi\n\n    def print_info(self):\n\"\"\"\n        output the size and the upper mode cut-off frequency\n        \"\"\"\n        fc_20 = self.f_cut_off(2, 0)\n        return f\"Width: {self.width * 1e3:.2f} mm\\tfc20: {fc_20 * 1e-9:.2f} GHz\"\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.f_cut_off","title":"<code>f_cut_off(_m=1, _n=0)</code>","text":"<p>return the value of the cut-off frequency of the TEM mode _m, _n</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def f_cut_off(self, _m=1, _n=0) -&gt; float:\n\"\"\"\n    return the value of the cut-off frequency of the TEM mode _m, _n\n    \"\"\"\n    if _n &gt; 0:\n        raise ValueError(\"Value of _n greater than 0 are not supported\")\n    if _m % 2 == 1:\n        res = minimize_scalar(self.__odd_fc)\n    else:\n        f_c = self.f_c\n        res = minimize_scalar(\n            self.__even_fc, bounds=(1.5 * f_c, 5 * f_c), method=\"bounded\"\n        )\n    return res.x\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.AF_SIW.print_info","title":"<code>print_info()</code>","text":"<p>output the size and the upper mode cut-off frequency</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def print_info(self):\n\"\"\"\n    output the size and the upper mode cut-off frequency\n    \"\"\"\n    fc_20 = self.f_cut_off(2, 0)\n    return f\"Width: {self.width * 1e3:.2f} mm\\tfc20: {fc_20 * 1e-9:.2f} GHz\"\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide","title":"<code>Waveguide</code>","text":"<p>Create an SIW object with a given geometry</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>class Waveguide:\n\"\"\"\n    Create an SIW object with a given geometry\n    \"\"\"\n\n    def __init__(self, _metal, _diel, _height):\n        self.metal = _metal\n        self.diel = _diel\n        self.width = 0.0\n        self.first_cut_off = 0.0\n        self.height = _height\n        self.eta = np.sqrt(u0 / (self.diel.epsilon * eps0))\n\n    @property\n    def width(self) -&gt; float:\n        if self.f_c &lt;= 0.0:\n            return self._w\n        self._w = c0 / (self.f_c * 2 * np.sqrt(self.diel.epsilon))\n        return self._w\n\n    @width.setter\n    def width(self, _width):\n\"\"\"\n        set the width of the wave-guide and update the cut-off frequency\n        \"\"\"\n        self._w = _width\n\n    @property\n    def first_cut_off(self):\n        self.f_c = self.f_cut_off()\n        return self.f_c\n\n    @first_cut_off.setter\n    def first_cut_off(self, _fc):\n\"\"\"\n        set the cut-off frequency of the wave-guide and update the width\n        \"\"\"\n        self.f_c = _fc\n\n    def f_cut_off(self, _m=1, _n=0):\n\"\"\"\n        return the value of the cut-off frequency of the TEM mode _m, _n\n        \"\"\"\n        eps = self.diel.epsilon\n        return (\n            c0\n            * np.sqrt((_m * np.pi / self.width) ** 2 + (_n * np.pi / self.height) ** 2)\n            / (2 * np.pi * np.sqrt(eps))\n        )\n\n    def calc_k(self, _freq):\n\"\"\"\n        convert the freq in pulsation in the given substrate\n        \"\"\"\n        return np.sqrt(self.diel.epsilon) * 2 * np.pi * _freq / c0\n\n    def calc_lambda(self, _f):\n\"\"\"\n        return the wavelength inside the waveguide at the given frequency _f\n        \"\"\"\n        return c0 / (_f * np.sqrt(1 - (self.f_c / _f) ** 2))\n\n    def calc_beta(self, _freq):\n\"\"\"\n        return the value of the velocity (beta)\n        \"\"\"\n        return np.sqrt(self.calc_k(_freq) ** 2 - (np.pi / self.width) ** 2)\n\n    def calc_a_d(self, _freq):\n\"\"\"\n        return the value of the dielectric loss in dB/m at the frequency freq (array-like)\n        \"\"\"\n        k = self.calc_k(_freq)\n        tan_d = self.diel.tan_d\n        beta = self.calc_beta(_freq)\n        return Nm_to_dBcm * k**2 * tan_d / (2 * beta)\n\n    def calc_a_c(self, _freq):\n\"\"\"\n        return the value of the conductor loss in dB/m at the frequency freq (array-like)\n        \"\"\"\n        r_s = np.sqrt(2 * np.pi * _freq * u0 / (2 * self.metal.rho))\n        eta = self.eta\n        k = self.calc_k(_freq)\n        beta = self.calc_beta(_freq)\n        height = self.height\n        width = self.width\n        return (\n            Nm_to_dBcm\n            * r_s\n            * (2 * height * np.pi**2 + width**3 * k**2)\n            / ((width**3) * height * beta * k * eta)\n        )\n\n    def calc_ksr(self, _freq):\n\"\"\"\n        return the coefficient of the added conductor loss introduce by surface roughness\n        \"\"\"\n        rho = self.metal.rho\n        skin_d = 1 / np.sqrt(rho * np.pi * _freq * u0)\n        rough = self.diel.roughness\n        if rough &lt;= 0:\n            raise ValueError(\n                \"Roughness must be above zero. \\\nValue can be set through /self.diel.roughness/\"\n            )\n        return 2 * np.arctan(1.4 * (rough / skin_d) ** 2) / np.pi\n\n    def calc_pphc(self, _freq, _e_0):\n\"\"\"\n        return the peak power handling capability in watt\n        at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m)\n        \"\"\"\n        width = self.width\n        if width &lt;= 0.0:\n            raise ValueError(\n                \"Width must be above zero. \\\nValue can be set using set_width() or set_f_c()\"\n            )\n        height = self.height\n        f_c = self.first_cut_off\n        eps = self.diel.epsilon\n        return (\n            0.25\n            * np.sqrt(eps)\n            * np.sqrt(1 - (f_c / _freq) ** 2)\n            * width\n            * height\n            * _e_0**2\n            / eta0\n        )\n\n    def calc_aphc(self, _freq, _t_max, t_amb=295) -&gt; float:\n        # using doi.org/10.1109/TADVP.2008.927814\n        a = self.width\n        alpha = self.calc_a_c(_freq) / Nm_to_dBcm + self.calc_a_d(_freq) / Nm_to_dBcm\n        # see page 346 of Heat Transfert, 10th edition\n        h_uc = 1.32 * ((_t_max - t_amb) / a) ** 0.25\n        h_dc = 0.59 * ((_t_max - t_amb) / a) ** 0.25\n        # see page 461 of Heat Transfert, 10th edition (with A2 &gt;&gt; A1)\n        sigma = 5.669 * 1e-8  # W/m\u00b2K^4 Stefan-Boltzmann constant\n        epsilon = 0.65  # emissivity of the copper\n        h_r = sigma * epsilon * (_t_max**2 + t_amb**2) * (_t_max + t_amb)\n        return (h_uc + h_dc + 2 * h_r) * a * (_t_max - t_amb) / alpha\n\n    def print_info(self):\n\"\"\"\n        output the size and the upper mode cut-off frequency\n        \"\"\"\n        fc_01 = self.f_cut_off(0, 1)\n        return f\"Width: {self.width * 1e3:.2f} mm\\tfc01: {fc_01 * 1e-9:.2f} GHz\"\n\n    def get_sparam(self, _freq, _length):\n\"\"\"\n        return the 4 scattering parameters of a wave-guide section\n        of the given length for the given frequency\n        \"\"\"\n        s11 = 0\n        alpha = self.calc_a_c(_freq) + (1 + self.calc_ksr(_freq)) * self.calc_a_d(_freq)\n        s21 = (1 - s11) * np.exp(-(alpha + 1j * self.calc_beta(_freq)) * _length)\n        return s21\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_a_c","title":"<code>calc_a_c(_freq)</code>","text":"<p>return the value of the conductor loss in dB/m at the frequency freq (array-like)</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def calc_a_c(self, _freq):\n\"\"\"\n    return the value of the conductor loss in dB/m at the frequency freq (array-like)\n    \"\"\"\n    r_s = np.sqrt(2 * np.pi * _freq * u0 / (2 * self.metal.rho))\n    eta = self.eta\n    k = self.calc_k(_freq)\n    beta = self.calc_beta(_freq)\n    height = self.height\n    width = self.width\n    return (\n        Nm_to_dBcm\n        * r_s\n        * (2 * height * np.pi**2 + width**3 * k**2)\n        / ((width**3) * height * beta * k * eta)\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_a_d","title":"<code>calc_a_d(_freq)</code>","text":"<p>return the value of the dielectric loss in dB/m at the frequency freq (array-like)</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def calc_a_d(self, _freq):\n\"\"\"\n    return the value of the dielectric loss in dB/m at the frequency freq (array-like)\n    \"\"\"\n    k = self.calc_k(_freq)\n    tan_d = self.diel.tan_d\n    beta = self.calc_beta(_freq)\n    return Nm_to_dBcm * k**2 * tan_d / (2 * beta)\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_beta","title":"<code>calc_beta(_freq)</code>","text":"<p>return the value of the velocity (beta)</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def calc_beta(self, _freq):\n\"\"\"\n    return the value of the velocity (beta)\n    \"\"\"\n    return np.sqrt(self.calc_k(_freq) ** 2 - (np.pi / self.width) ** 2)\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_k","title":"<code>calc_k(_freq)</code>","text":"<p>convert the freq in pulsation in the given substrate</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def calc_k(self, _freq):\n\"\"\"\n    convert the freq in pulsation in the given substrate\n    \"\"\"\n    return np.sqrt(self.diel.epsilon) * 2 * np.pi * _freq / c0\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_ksr","title":"<code>calc_ksr(_freq)</code>","text":"<p>return the coefficient of the added conductor loss introduce by surface roughness</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>    def calc_ksr(self, _freq):\n\"\"\"\n        return the coefficient of the added conductor loss introduce by surface roughness\n        \"\"\"\n        rho = self.metal.rho\n        skin_d = 1 / np.sqrt(rho * np.pi * _freq * u0)\n        rough = self.diel.roughness\n        if rough &lt;= 0:\n            raise ValueError(\n                \"Roughness must be above zero. \\\nValue can be set through /self.diel.roughness/\"\n            )\n        return 2 * np.arctan(1.4 * (rough / skin_d) ** 2) / np.pi\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_lambda","title":"<code>calc_lambda(_f)</code>","text":"<p>return the wavelength inside the waveguide at the given frequency _f</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def calc_lambda(self, _f):\n\"\"\"\n    return the wavelength inside the waveguide at the given frequency _f\n    \"\"\"\n    return c0 / (_f * np.sqrt(1 - (self.f_c / _f) ** 2))\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.calc_pphc","title":"<code>calc_pphc(_freq, _e_0)</code>","text":"<p>return the peak power handling capability in watt at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m)</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>    def calc_pphc(self, _freq, _e_0):\n\"\"\"\n        return the peak power handling capability in watt\n        at the _freq frequency (in GHz) and for a maximum electric field _e_0 (in V/m)\n        \"\"\"\n        width = self.width\n        if width &lt;= 0.0:\n            raise ValueError(\n                \"Width must be above zero. \\\nValue can be set using set_width() or set_f_c()\"\n            )\n        height = self.height\n        f_c = self.first_cut_off\n        eps = self.diel.epsilon\n        return (\n            0.25\n            * np.sqrt(eps)\n            * np.sqrt(1 - (f_c / _freq) ** 2)\n            * width\n            * height\n            * _e_0**2\n            / eta0\n        )\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.f_cut_off","title":"<code>f_cut_off(_m=1, _n=0)</code>","text":"<p>return the value of the cut-off frequency of the TEM mode _m, _n</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def f_cut_off(self, _m=1, _n=0):\n\"\"\"\n    return the value of the cut-off frequency of the TEM mode _m, _n\n    \"\"\"\n    eps = self.diel.epsilon\n    return (\n        c0\n        * np.sqrt((_m * np.pi / self.width) ** 2 + (_n * np.pi / self.height) ** 2)\n        / (2 * np.pi * np.sqrt(eps))\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.get_sparam","title":"<code>get_sparam(_freq, _length)</code>","text":"<p>return the 4 scattering parameters of a wave-guide section of the given length for the given frequency</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def get_sparam(self, _freq, _length):\n\"\"\"\n    return the 4 scattering parameters of a wave-guide section\n    of the given length for the given frequency\n    \"\"\"\n    s11 = 0\n    alpha = self.calc_a_c(_freq) + (1 + self.calc_ksr(_freq)) * self.calc_a_d(_freq)\n    s21 = (1 - s11) * np.exp(-(alpha + 1j * self.calc_beta(_freq)) * _length)\n    return s21\n</code></pre>"},{"location":"reference/passive_auto_design/components/waveguide/#passive_auto_design.components.waveguide.Waveguide.print_info","title":"<code>print_info()</code>","text":"<p>output the size and the upper mode cut-off frequency</p> Source code in <code>passive_auto_design\\components\\waveguide.py</code> <pre><code>def print_info(self):\n\"\"\"\n    output the size and the upper mode cut-off frequency\n    \"\"\"\n    fc_01 = self.f_cut_off(0, 1)\n    return f\"Width: {self.width * 1e3:.2f} mm\\tfc01: {fc_01 * 1e-9:.2f} GHz\"\n</code></pre>"},{"location":"reference/passive_auto_design/devices/","title":"devices","text":"<p>Devices are elements that create link between general specifications and electrical behavior. For example, balun create en link between input and ouput impedances and inductor value of the balun.</p>"},{"location":"reference/passive_auto_design/devices/balun/","title":"balun","text":"<p>Class to calculate the inductors values of an impedance transformer.</p>"},{"location":"reference/passive_auto_design/devices/balun/#passive_auto_design.devices.balun.Balun","title":"<code>Balun</code>","text":"<p>Create a balun object</p> Source code in <code>passive_auto_design\\devices\\balun.py</code> <pre><code>class Balun:\n\"\"\"\n    Create a balun object\n    \"\"\"\n\n    def __init__(self, _fc=1e9, _z_source=50, _z_load=50, _k=0.9):\n        self.f_c = _fc\n        self.z_src = _z_source\n        self.z_ld = _z_load\n        self.k = _k\n\n    def __str__(self):\n        message = f\"target : fc={Frequency(self.f_c)}\\tzs={Impedance(self.z_src)}\\tzl={Impedance(self.z_ld)}\"\n        return message\n\n    def design(self, XL_add=(0.0, 0.0), XS_add=(0.0, 0.0), r_serie=(0.0, 0.0)):\n\"\"\"\n        design an impedance transformer\n        with the targeted specifications (f_targ, zl_targ, zs_targ, k)\n        return the two ideal transformers solution\n        \"\"\"\n        k = self.k\n        alpha = (1 - k**2) / k**2\n        q_s = -quality_f(self.z_src + 1j * np.array(XS_add))\n        q_l = -quality_f(self.z_ld + 1j * np.array(XL_add))\n        # assuming perfect inductor for first calculation\n        r_l1, r_l2 = r_serie\n        q_s_prime = q_s * np.real(self.z_src) / (np.real(self.z_src) + r_l1)\n        q_l_prime = q_l * np.real(self.z_ld) / (np.real(self.z_ld) + r_l2)\n        b_coeff = 2 * alpha * q_s_prime + q_s_prime + q_l_prime\n        discr = b_coeff**2 - 4 * alpha * (alpha + 1) * (1 + q_s_prime**2)\n        z_sol = np.array(\n            (\n                (b_coeff[0] + np.sqrt(discr[0])) / (2 * (alpha + 1)),\n                (b_coeff[1] - np.sqrt(discr[1])) / (2 * (alpha + 1)),\n            )\n        )\n        qxl1 = z_sol / (1 - k**2)\n        qxl2 = z_sol * (1 + q_l_prime**2) / (alpha * (1 + (q_s_prime - z_sol) ** 2))\n        l_sol1 = qxl1 * np.real(self.z_src) / (2 * np.pi * self.f_c)\n        l_sol2 = qxl2 * np.real(self.z_ld) / (2 * np.pi * self.f_c)\n        return l_sol1, l_sol2\n\n    def __enforce_symmetrical(self, _X_val, _of_load=True, sol=0):\n\"\"\"\n        return the 'distance' to a symmetrical balun (ie. primary = secondary)\n        if _of_load, altering the load reactance\n        else altering the source reactance\n        \"\"\"\n        X_add = ((1 - sol) * _X_val, sol * _X_val)\n        if _of_load:\n            l1, l2 = self.design(XL_add=X_add)\n        else:\n            l1, l2 = self.design(XS_add=X_add)\n        return float(np.abs(l1[sol] - l2[sol])[0])\n\n    def enforce_symmetrical(self, side=\"load\", _verbose=False):\n\"\"\"\n        return the reactance to be added to the load (if side=\"load\") or the source impedance\n        in order to realize a symmetrical balun (ie. primary = secondary)\n        the two solution match the two solutions of the design\n        \"\"\"\n        if side == \"load\":\n            old_z = self.z_ld\n            _through_load = True\n        else:\n            old_z = self.z_src\n            _through_load = False\n        # TODO : Detect when minimize did not converge\n        res = list((0, 1))\n        for i in (0, 1):\n            t = minimize(\n                self.__enforce_symmetrical,\n                quality_f(old_z),\n                args=(_through_load, i),\n                method=\"Nelder-Mead\",\n            )\n            res[i] = t.x[0]\n        if _verbose:\n            print(f\"X_{side} must be change by {res[0]:5.2f} or {res[1]:5.2f}\")\n        return res\n</code></pre>"},{"location":"reference/passive_auto_design/devices/balun/#passive_auto_design.devices.balun.Balun.__enforce_symmetrical","title":"<code>__enforce_symmetrical(_X_val, _of_load=True, sol=0)</code>","text":"<p>return the 'distance' to a symmetrical balun (ie. primary = secondary) if _of_load, altering the load reactance else altering the source reactance</p> Source code in <code>passive_auto_design\\devices\\balun.py</code> <pre><code>def __enforce_symmetrical(self, _X_val, _of_load=True, sol=0):\n\"\"\"\n    return the 'distance' to a symmetrical balun (ie. primary = secondary)\n    if _of_load, altering the load reactance\n    else altering the source reactance\n    \"\"\"\n    X_add = ((1 - sol) * _X_val, sol * _X_val)\n    if _of_load:\n        l1, l2 = self.design(XL_add=X_add)\n    else:\n        l1, l2 = self.design(XS_add=X_add)\n    return float(np.abs(l1[sol] - l2[sol])[0])\n</code></pre>"},{"location":"reference/passive_auto_design/devices/balun/#passive_auto_design.devices.balun.Balun.design","title":"<code>design(XL_add=(0.0, 0.0), XS_add=(0.0, 0.0), r_serie=(0.0, 0.0))</code>","text":"<p>design an impedance transformer with the targeted specifications (f_targ, zl_targ, zs_targ, k) return the two ideal transformers solution</p> Source code in <code>passive_auto_design\\devices\\balun.py</code> <pre><code>def design(self, XL_add=(0.0, 0.0), XS_add=(0.0, 0.0), r_serie=(0.0, 0.0)):\n\"\"\"\n    design an impedance transformer\n    with the targeted specifications (f_targ, zl_targ, zs_targ, k)\n    return the two ideal transformers solution\n    \"\"\"\n    k = self.k\n    alpha = (1 - k**2) / k**2\n    q_s = -quality_f(self.z_src + 1j * np.array(XS_add))\n    q_l = -quality_f(self.z_ld + 1j * np.array(XL_add))\n    # assuming perfect inductor for first calculation\n    r_l1, r_l2 = r_serie\n    q_s_prime = q_s * np.real(self.z_src) / (np.real(self.z_src) + r_l1)\n    q_l_prime = q_l * np.real(self.z_ld) / (np.real(self.z_ld) + r_l2)\n    b_coeff = 2 * alpha * q_s_prime + q_s_prime + q_l_prime\n    discr = b_coeff**2 - 4 * alpha * (alpha + 1) * (1 + q_s_prime**2)\n    z_sol = np.array(\n        (\n            (b_coeff[0] + np.sqrt(discr[0])) / (2 * (alpha + 1)),\n            (b_coeff[1] - np.sqrt(discr[1])) / (2 * (alpha + 1)),\n        )\n    )\n    qxl1 = z_sol / (1 - k**2)\n    qxl2 = z_sol * (1 + q_l_prime**2) / (alpha * (1 + (q_s_prime - z_sol) ** 2))\n    l_sol1 = qxl1 * np.real(self.z_src) / (2 * np.pi * self.f_c)\n    l_sol2 = qxl2 * np.real(self.z_ld) / (2 * np.pi * self.f_c)\n    return l_sol1, l_sol2\n</code></pre>"},{"location":"reference/passive_auto_design/devices/balun/#passive_auto_design.devices.balun.Balun.enforce_symmetrical","title":"<code>enforce_symmetrical(side='load', _verbose=False)</code>","text":"<p>return the reactance to be added to the load (if side=\"load\") or the source impedance in order to realize a symmetrical balun (ie. primary = secondary) the two solution match the two solutions of the design</p> Source code in <code>passive_auto_design\\devices\\balun.py</code> <pre><code>def enforce_symmetrical(self, side=\"load\", _verbose=False):\n\"\"\"\n    return the reactance to be added to the load (if side=\"load\") or the source impedance\n    in order to realize a symmetrical balun (ie. primary = secondary)\n    the two solution match the two solutions of the design\n    \"\"\"\n    if side == \"load\":\n        old_z = self.z_ld\n        _through_load = True\n    else:\n        old_z = self.z_src\n        _through_load = False\n    # TODO : Detect when minimize did not converge\n    res = list((0, 1))\n    for i in (0, 1):\n        t = minimize(\n            self.__enforce_symmetrical,\n            quality_f(old_z),\n            args=(_through_load, i),\n            method=\"Nelder-Mead\",\n        )\n        res[i] = t.x[0]\n    if _verbose:\n        print(f\"X_{side} must be change by {res[0]:5.2f} or {res[1]:5.2f}\")\n    return res\n</code></pre>"},{"location":"reference/passive_auto_design/devices/coupler/","title":"coupler","text":""},{"location":"reference/passive_auto_design/devices/coupler/#passive_auto_design.devices.coupler.Coupler","title":"<code>Coupler</code>","text":"<p>Create a coupler object</p> Source code in <code>passive_auto_design\\devices\\coupler.py</code> <pre><code>class Coupler:\n\"\"\"\n    Create a coupler object\n    \"\"\"\n\n    def __init__(self, _fc=1e9, _zc=50, _k=0.707):\n        self.f_c = _fc\n        self.z_c = _zc\n        self.k = _k\n        self.l = self.z_c / (2 * pi * self.f_c * sqrt(1 - self.k**2))\n        self.c = self.l / self.z_c**2\n\n    def __str__(self):\n\"\"\"\n        Print a summary of the solution l and c\n        \"\"\"\n        message = f\"L: {SI(self.l)}H\\tC: {SI(self.c)}F\"\n        return message\n</code></pre>"},{"location":"reference/passive_auto_design/devices/coupler/#passive_auto_design.devices.coupler.Coupler.__str__","title":"<code>__str__()</code>","text":"<p>Print a summary of the solution l and c</p> Source code in <code>passive_auto_design\\devices\\coupler.py</code> <pre><code>def __str__(self):\n\"\"\"\n    Print a summary of the solution l and c\n    \"\"\"\n    message = f\"L: {SI(self.l)}H\\tC: {SI(self.c)}F\"\n    return message\n</code></pre>"},{"location":"reference/passive_auto_design/devices/filter/","title":"filter","text":"<p>specify a filter mask from a given mask</p>"},{"location":"reference/passive_auto_design/devices/filter/#passive_auto_design.devices.filter.Filter","title":"<code>Filter</code>","text":"Source code in <code>passive_auto_design\\devices\\filter.py</code> <pre><code>class Filter:\n    Order: int\n\n    def __init__(\n        self,\n        f_pass: Frequency,\n        f_stop: Frequency,\n        ripple: PhysicalDimension,\n        atten: PhysicalDimension,\n    ):\n\"\"\"\n        f_pass: pass-band edge frequency\n        f_stop: stop-band edge frequency\n        ripple: maximum ripple in the pass band in dB\n        atten: minimum attenuation in the stop band in dB\n        \"\"\"\n\n        # tchebychev\n        epsilon = sqrt(ripple.lin() - 1)\n        a_2 = atten.lin()\n        k1 = PhysicalDimension(value=epsilon / sqrt(a_2 - 1))\n        k = f_pass.lin() / f_stop.lin()\n        self.Order = ceil(k1.dB() / k.dB())\n</code></pre>"},{"location":"reference/passive_auto_design/devices/filter/#passive_auto_design.devices.filter.Filter.__init__","title":"<code>__init__(f_pass, f_stop, ripple, atten)</code>","text":"<p>f_pass: pass-band edge frequency f_stop: stop-band edge frequency ripple: maximum ripple in the pass band in dB atten: minimum attenuation in the stop band in dB</p> Source code in <code>passive_auto_design\\devices\\filter.py</code> <pre><code>def __init__(\n    self,\n    f_pass: Frequency,\n    f_stop: Frequency,\n    ripple: PhysicalDimension,\n    atten: PhysicalDimension,\n):\n\"\"\"\n    f_pass: pass-band edge frequency\n    f_stop: stop-band edge frequency\n    ripple: maximum ripple in the pass band in dB\n    atten: minimum attenuation in the stop band in dB\n    \"\"\"\n\n    # tchebychev\n    epsilon = sqrt(ripple.lin() - 1)\n    a_2 = atten.lin()\n    k1 = PhysicalDimension(value=epsilon / sqrt(a_2 - 1))\n    k = f_pass.lin() / f_stop.lin()\n    self.Order = ceil(k1.dB() / k.dB())\n</code></pre>"},{"location":"reference/passive_auto_design/devices/taper/","title":"taper","text":"<p>This module give function to ease the design of RF-tapper</p>"},{"location":"reference/passive_auto_design/devices/taper/#passive_auto_design.devices.taper.klopfenstein_taper","title":"<code>klopfenstein_taper(_z_start, _z_stop, _n_step, _rhomax=0.01)</code>","text":"<p>return the _n_step profile of impedance for a transition from _z_start to _z_stop</p> Source code in <code>passive_auto_design\\devices\\taper.py</code> <pre><code>def klopfenstein_taper(_z_start, _z_stop, _n_step, _rhomax=0.01):\n\"\"\"\n    return the _n_step profile of impedance for a transition from\n    _z_start to _z_stop\n    \"\"\"\n    rho0 = gamma(_z_start, _z_stop)\n    z_mid = 0.5 * np.log(_z_stop * _z_start)\n    n_mid = int(np.floor(_n_step / 2))\n    a_coeff = np.arccosh(rho0.value / _rhomax)\n    ln_z = np.zeros((_n_step,))\n    for i in range(1, n_mid + 1):\n        ln_z[i + n_mid] = z_mid + _rhomax * (\n            1 + a_coeff**2 * __phi(a_coeff, i / n_mid)\n        )\n        ln_z[n_mid - i] = z_mid + _rhomax * (\n            1 - a_coeff**2 * __phi(a_coeff, i / n_mid)\n        )\n    ln_z[n_mid] = z_mid + _rhomax\n    return PhysicalDimension(\n        value=np.exp(ln_z, dtype=complex), scale=\"lin\", unit=r\"$\\Omega$\"\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/devices/taper/#passive_auto_design.devices.taper.linear_taper","title":"<code>linear_taper(_z_start, _z_stop, _n_step)</code>","text":"<p>return the _n_step profile of impedance for a transition from _z_start to _z_stop</p> Source code in <code>passive_auto_design\\devices\\taper.py</code> <pre><code>def linear_taper(_z_start, _z_stop, _n_step):\n\"\"\"\n    return the _n_step profile of impedance for a transition from\n    _z_start to _z_stop\n    \"\"\"\n    return PhysicalDimension(\n        value=np.linspace(_z_start, _z_stop, _n_step, dtype=complex),\n        scale=\"lin\",\n        unit=r\"\\Omega\",\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/system/","title":"system","text":""},{"location":"reference/passive_auto_design/system/pll/","title":"pll","text":""},{"location":"reference/passive_auto_design/system/rf_line_up/","title":"rf_line_up","text":""},{"location":"reference/passive_auto_design/system/rf_line_up/#passive_auto_design.system.rf_line_up.RFBloc","title":"<code>RFBloc</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>class used to defined RF-bloc.</p> Source code in <code>passive_auto_design\\system\\rf_line_up.py</code> <pre><code>class RFBloc(BaseModel):\n\"\"\"\n    class used to defined RF-bloc.\n    \"\"\"\n\n    freq: Frequency\n    gain: PhysicalDimension\n    noise: Optional[NoiseFigure]\n\n    @validator(\"gain\", \"noise\")\n    def check_size(cls, v, values, field):\n        if \"freq\" in values and v.shape != values[\"freq\"].shape:\n            raise ValueError(f\"freq and {field.name} must be the same length\")\n        return v\n</code></pre>"},{"location":"reference/passive_auto_design/system/rf_line_up/#passive_auto_design.system.rf_line_up.RFLineUp","title":"<code>RFLineUp</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>class used to size rf line-up</p> Source code in <code>passive_auto_design\\system\\rf_line_up.py</code> <pre><code>class RFLineUp(BaseModel):\n\"\"\"\n    class used to size rf line-up\n    \"\"\"\n\n    chain: List[RFBloc]\n\n    def NF(self):\n\"\"\"\n        return the noise figure of the global line-up.\n        \"\"\"\n        NF = NoiseFigure(value=list(l.noise.value for l in self.chain))\n        gain = PhysicalDimension(\n            value=list(l.gain.dB().value for l in self.chain)[:-1], scale=\"dB\"\n        )\n        return friis(NF, gain)\n\n    def gain(self):\n\"\"\"\n        return the gain of the global line-up.\n        \"\"\"\n        gain = np.zeros(self.chain[0].gain.shape)\n        for l in self.chain:\n            gain += l.gain.dB().value\n        print(gain)\n        return sum(gain)\n</code></pre>"},{"location":"reference/passive_auto_design/system/rf_line_up/#passive_auto_design.system.rf_line_up.RFLineUp.NF","title":"<code>NF()</code>","text":"<p>return the noise figure of the global line-up.</p> Source code in <code>passive_auto_design\\system\\rf_line_up.py</code> <pre><code>def NF(self):\n\"\"\"\n    return the noise figure of the global line-up.\n    \"\"\"\n    NF = NoiseFigure(value=list(l.noise.value for l in self.chain))\n    gain = PhysicalDimension(\n        value=list(l.gain.dB().value for l in self.chain)[:-1], scale=\"dB\"\n    )\n    return friis(NF, gain)\n</code></pre>"},{"location":"reference/passive_auto_design/system/rf_line_up/#passive_auto_design.system.rf_line_up.RFLineUp.gain","title":"<code>gain()</code>","text":"<p>return the gain of the global line-up.</p> Source code in <code>passive_auto_design\\system\\rf_line_up.py</code> <pre><code>def gain(self):\n\"\"\"\n    return the gain of the global line-up.\n    \"\"\"\n    gain = np.zeros(self.chain[0].gain.shape)\n    for l in self.chain:\n        gain += l.gain.dB().value\n    print(gain)\n    return sum(gain)\n</code></pre>"},{"location":"reference/passive_auto_design/system/rf_line_up/#passive_auto_design.system.rf_line_up.friis","title":"<code>friis(nf, gain)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>nf</code> <code>NoiseFigure</code> <p>List of the noise figure (in dB) of each block.</p> required <code>gain</code> <code>PhysicalDimension</code> <p>List of the gain of each block (in dB).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total noise figure of the system</p> Source code in <code>passive_auto_design\\system\\rf_line_up.py</code> <pre><code>def friis(nf: NoiseFigure, gain: PhysicalDimension):\n\"\"\"\n\n    Parameters\n    ----------\n    nf : NoiseFigure\n        List of the noise figure (in dB) of each block.\n    gain : PhysicalDimension\n        List of the gain of each block (in dB).\n\n\n    Returns\n    -------\n    float\n        Total noise figure of the system\n\n    \"\"\"\n\n    m = gain.shape[0]\n    n = nf.shape[0]\n    if m != n - 1:\n        raise ValueError(\"gain should have 1 item less than noise factor f\")\n    g_tot = 1.0\n    f_lin = nf.lin()\n    res = f_lin[0]\n    for i in range(m):\n        g_tot *= gain[i].lin()\n        res += (f_lin[i + 1] - 1) / g_tot\n    return res.dB()\n</code></pre>"},{"location":"reference/passive_auto_design/units/","title":"units","text":"<p>Pydantic Model for all physical dimensions.</p>"},{"location":"reference/passive_auto_design/units/constants/","title":"constants","text":""},{"location":"reference/passive_auto_design/units/converters/","title":"converters","text":""},{"location":"reference/passive_auto_design/units/converters/#passive_auto_design.units.converters.__pn_interpol","title":"<code>__pn_interpol(pn_db, freq, f_int)</code>","text":"<p>Interpolator for phase noise.</p> Source code in <code>passive_auto_design\\units\\converters.py</code> <pre><code>def __pn_interpol(pn_db: PhaseNoise, freq: Frequency, f_int: Frequency):\n\"\"\"\n    Interpolator for phase noise.\n    \"\"\"\n    a = (pn_db[1] - pn_db[0]) / (freq[1].dB() - freq[0].dB())\n    b = pn_db[1] - a * freq[1].dB()\n    return b + a * f_int.dB()\n</code></pre>"},{"location":"reference/passive_auto_design/units/converters/#passive_auto_design.units.converters.int_phase_noise","title":"<code>int_phase_noise(pn_db, freq, f_min=None, f_max=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>pn_db</code> <code>PhaseNoise</code> <p>List of the phase noise in dBc/Hz</p> required <code>freq</code> <code>Frequency</code> <p>List of the corresponding frequency (in Hz)</p> required <code>f_min</code> <code>Frequency</code> <p>f_min</p> <code>None</code> <code>f_max</code> <code>Frequency</code> <p>if not None, calculation is done from f_min to f_max (with interpolation)</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>integrated phase noise of the piece wise phase noise curve (in radian)</p> Source code in <code>passive_auto_design\\units\\converters.py</code> <pre><code>def int_phase_noise(\n    pn_db: PhaseNoise,\n    freq: Frequency,\n    f_min: Frequency = None,\n    f_max: Frequency = None,\n):\n\"\"\"\n\n    Parameters\n    ----------\n    pn_db : PhaseNoise\n        List of the phase noise in dBc/Hz\n    freq : Frequency\n        List of the corresponding frequency (in Hz)\n    f_min : Frequency\n        f_min\n    f_max : Frequency\n        if not None, calculation is done from f_min to f_max (with interpolation)\n\n\n    Returns\n    -------\n    float\n        integrated phase noise of the piece wise phase noise curve (in radian)\n\n    \"\"\"\n    pn_shape = len(pn_db.value)\n    f_shape = len(freq.value)\n    if pn_shape != f_shape:\n        raise ValueError(f\"Expected identical shape, got {pn_shape} and {f_shape}\")\n    ipn = PhysicalDimension(value=(0.0,), scale=\"lin\", unit=\"\")\n    for i in range(pn_shape - 1):\n        if f_min is not None and f_min.value &gt; freq[i + 1].value:\n            # skipping all part bellow f_min\n            continue\n        if f_min is not None and f_min &gt; freq[i]:\n            f1 = f_min if type(f_min) is Frequency else Frequency(value=f_min)\n            pn1_db = __pn_interpol(pn_db[i : i + 2], freq[i : i + 2], f_min)\n        else:\n            f1 = freq[i]\n            pn1_db = pn_db[i]\n\n        if f_max is not None and freq[i] &gt; f_max:\n            continue\n        if f_max is not None and freq[i + 1] &lt; f_max:\n            f2 = f_max if type(f_max) is Frequency else Frequency(value=f_max)\n            pn2_db = __pn_interpol(pn_db[i : i + 2], freq[i : i + 2], f_max)\n        else:\n            f2 = freq[i + 1]\n            pn2_db = pn_db[i + 1]\n        A = (pn1_db - pn2_db) / (f1.dB() - f2.dB())\n        ipn += (f2 * pn2_db.lin() - f1 * pn1_db.lin()) / (A + 1)\n    return ipn\n</code></pre>"},{"location":"reference/passive_auto_design/units/converters/#passive_auto_design.units.converters.to_jitter","title":"<code>to_jitter(ipn, f0)</code>","text":"<p>Convert Integrated Phase Noise to equivalent Jitter.</p> <p>Parameters:</p> Name Type Description Default <code>ipn</code> <code>float</code> <p>integrated phase noise of a system</p> required <code>f0</code> <code>float</code> <p>central frequency of the system</p> required <p>Returns:</p> Type Description <code>float</code> <p>equivalent jitter in seconds</p> Source code in <code>passive_auto_design\\units\\converters.py</code> <pre><code>def to_jitter(ipn: IntegratedPhaseNoise, f0: Frequency):\n\"\"\"\n    Convert Integrated Phase Noise to equivalent Jitter.\n\n    Parameters\n    ----------\n    ipn : float\n        integrated phase noise of a system\n    f0 : float\n        central frequency of the system\n\n    Returns\n    -------\n    float\n        equivalent jitter in seconds\n\n    \"\"\"\n    return Time(value=np.sqrt(2 * ipn.value) / (2 * np.pi * f0))\n</code></pre>"},{"location":"reference/passive_auto_design/units/noise/","title":"noise","text":""},{"location":"reference/passive_auto_design/units/noise/#passive_auto_design.units.noise.IntegratedPhaseNoise","title":"<code>IntegratedPhaseNoise</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Integrated Phase Noise PhysicalDimension, use for noise conversion (see ::converters).</p> Source code in <code>passive_auto_design\\units\\noise.py</code> <pre><code>class IntegratedPhaseNoise(PhysicalDimension):\n\"\"\"\n    Integrated Phase Noise PhysicalDimension, use for noise conversion (see ::converters).\n    \"\"\"\n\n    unit = \"rad\"\n\n    def __init__(self, scale=\"lin\", **data):\n        super().__init__(scale=scale, **data)\n</code></pre>"},{"location":"reference/passive_auto_design/units/noise/#passive_auto_design.units.noise.NoiseFigure","title":"<code>NoiseFigure</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Noise Figure, use for RF-line Up and friis formula.</p> Source code in <code>passive_auto_design\\units\\noise.py</code> <pre><code>class NoiseFigure(PhysicalDimension):\n\"\"\"\n    Noise Figure, use for RF-line Up and friis formula.\n    \"\"\"\n\n    unit = \"\"\n\n    def __init__(self, value, scale=\"dB\", **data):\n        super().__init__(value=value, scale=scale, **data)\n\n    def to_temp(self, Tref=290):\n        T = Tref * (self.lin() - 1)\n        return NoiseTemperature(value=T.value)\n</code></pre>"},{"location":"reference/passive_auto_design/units/noise/#passive_auto_design.units.noise.NoiseTemperature","title":"<code>NoiseTemperature</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Noise Temperature, use for RF-line Up.</p> Source code in <code>passive_auto_design\\units\\noise.py</code> <pre><code>class NoiseTemperature(PhysicalDimension):\n\"\"\"\n    Noise Temperature, use for RF-line Up.\n    \"\"\"\n\n    unit = \"K\"\n\n    def __init__(self, value, scale=\"lin\", **data):\n        super().__init__(value=value, scale=scale, **data)\n\n    def to_figure(self, Tref=290):\n        NF = (self / Tref + 1).dB()\n        return NoiseFigure(NF.value)\n</code></pre>"},{"location":"reference/passive_auto_design/units/noise/#passive_auto_design.units.noise.PhaseNoise","title":"<code>PhaseNoise</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Phase Noise PhysicalDimension, use for noise conversion (see ::converters).</p> Source code in <code>passive_auto_design\\units\\noise.py</code> <pre><code>class PhaseNoise(PhysicalDimension):\n\"\"\"\n    Phase Noise PhysicalDimension, use for noise conversion (see ::converters).\n    \"\"\"\n\n    unit = \"dBc/Hz\"\n\n    def __init__(self, scale=\"dB\", **data):\n        super().__init__(scale=scale, **data)\n</code></pre>"},{"location":"reference/passive_auto_design/units/physical_dimension/","title":"physical_dimension","text":""},{"location":"reference/passive_auto_design/units/physical_dimension/#passive_auto_design.units.physical_dimension.PhysicalDimension","title":"<code>PhysicalDimension</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Pydantic model adding unit and scale to standard ndarray.</p> Source code in <code>passive_auto_design\\units\\physical_dimension.py</code> <pre><code>class PhysicalDimension(BaseModel):\n\"\"\"\n    Pydantic model adding unit and scale to standard ndarray.\n    \"\"\"\n\n    value: NDArray\n    unit: str = \"\"\n    scale: Literal[\"lin\", \"dB\"] = \"lin\"\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def dB(self):\n\"\"\"\n        Convert the Physical dimension to decibel.\n        \"\"\"\n        v = self.value\n        v_db = v if self.scale == \"dB\" else 10 * np.log10(np.abs(v))\n        out = self.__class__(value=v_db, scale=\"dB\", unit=self.unit)\n        return out\n\n    def lin(self):\n\"\"\"\n        Convert the Physical dimension to linear magnitude.\n        \"\"\"\n        v = self.value\n        v_lin = 10 ** (v / 10) if self.scale == \"dB\" else v\n        return self.__class__(value=v_lin, scale=\"lin\", unit=self.unit)\n\n    def __getitem__(self, item):\n        return self.__class__(\n            value=self.value[item],\n            scale=self.scale,\n            unit=self.unit,\n        )\n\n    def __setitem__(self, key, value):\n        self.value[key] = value\n\n    @property\n    def shape(self):\n        return self.value.shape\n\n    def __sub__(self, other):\n        return self.__operator(other, \"-\")\n\n    def __rsub__(self, other):\n        return self.__operator(other, \"-\") * -1\n\n    def __add__(self, other):\n        return self.__operator(other, \"+\")\n\n    def __radd__(self, other):\n        return self.__operator(other, \"+\")\n\n    def __truediv__(self, other):\n        return self.__operator(other, \"/\")\n\n    def __mul__(self, other):\n        return self.__operator(other, \"*\")\n\n    def __rmul__(self, other):\n        return self.__operator(other, \"*\")\n\n    def __pow__(self, other):\n        return self.__operator(other, \"**\")\n\n    def __eq__(self, other):\n        if isinstance(other, PhysicalDimension):\n            return (\n                self.unit == other.unit\n                and self.scale == other.scale\n                and np.all(self.value == other.value)\n            )\n        else:\n            return np.all(self.value == other)\n\n    def __lt__(self, other):\n        return np.all(self.value &lt; other.value)\n\n    def __round__(self, x):\n        return self.__class__(\n            value=np.round(self.value, x), scale=self.scale, unit=self.unit\n        )\n\n    def __ceil__(self):\n        return self.__class__(\n            value=np.ceil(self.value), scale=self.scale, unit=self.unit\n        )\n\n    def rint(self):\n        return np.rint(self.value)\n\n    def sqrt(self):\n        return np.sqrt(self.value)\n\n    def __operator(self, l_b, op):\n        b = l_b.value if isinstance(l_b, PhysicalDimension) else l_b\n        if op == \"+\":\n            res = self.value + b\n        if op == \"-\":\n            res = self.value - b\n        if op == \"/\":\n            res = self.value / b\n        if op == \"*\":\n            res = self.value * b\n        if op == \"**\":\n            res = self.value**b\n        return self.__class__(value=np.array(res), scale=self.scale, unit=self.unit)\n</code></pre>"},{"location":"reference/passive_auto_design/units/physical_dimension/#passive_auto_design.units.physical_dimension.PhysicalDimension.dB","title":"<code>dB()</code>","text":"<p>Convert the Physical dimension to decibel.</p> Source code in <code>passive_auto_design\\units\\physical_dimension.py</code> <pre><code>def dB(self):\n\"\"\"\n    Convert the Physical dimension to decibel.\n    \"\"\"\n    v = self.value\n    v_db = v if self.scale == \"dB\" else 10 * np.log10(np.abs(v))\n    out = self.__class__(value=v_db, scale=\"dB\", unit=self.unit)\n    return out\n</code></pre>"},{"location":"reference/passive_auto_design/units/physical_dimension/#passive_auto_design.units.physical_dimension.PhysicalDimension.lin","title":"<code>lin()</code>","text":"<p>Convert the Physical dimension to linear magnitude.</p> Source code in <code>passive_auto_design\\units\\physical_dimension.py</code> <pre><code>def lin(self):\n\"\"\"\n    Convert the Physical dimension to linear magnitude.\n    \"\"\"\n    v = self.value\n    v_lin = 10 ** (v / 10) if self.scale == \"dB\" else v\n    return self.__class__(value=v_lin, scale=\"lin\", unit=self.unit)\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/","title":"time","text":""},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Frequency","title":"<code>Frequency</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Frequency class inherited from Physical Dimension.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>class Frequency(PhysicalDimension):\n\"\"\"\n    Frequency class inherited from Physical Dimension.\n    \"\"\"\n\n    unit = \"Hz\"\n\n    def __init__(self, value, scale=\"lin\", **data):\n        super().__init__(value=value, scale=scale, **data)\n\n    def to_time(self):\n\"\"\"\n        Convert the frequency to equivalent period.\n        \"\"\"\n        if self.scale == \"lin\":\n            return Time(value=1 / self.value, scale=self.scale)\n        return Time(value=-self.value, scale=self.scale)\n\n    def to_wavelength(self, eps_r: float = 1):\n\"\"\"\n        Convert the frequency to the equivalent wavelength.\n        eps_r : relative permittivity of the medium used.\n        \"\"\"\n        f_lin = self.lin()\n        return PhysicalDimension(\n            value=sqrt(eps_r) * c0 / f_lin.value, scale=\"lin\", unit=\"m\"\n        )\n\n    def fractionnal_bandwidth(self):\n\"\"\"\n        Return the fractionnal BandWidth in percent.\n        \"\"\"\n        f_min = min(self.lin().value)\n        f_max = max(self.lin().value)\n        return 100 * abs(f_max - f_min) / sqrt(f_max * f_min)\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Frequency.fractionnal_bandwidth","title":"<code>fractionnal_bandwidth()</code>","text":"<p>Return the fractionnal BandWidth in percent.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>def fractionnal_bandwidth(self):\n\"\"\"\n    Return the fractionnal BandWidth in percent.\n    \"\"\"\n    f_min = min(self.lin().value)\n    f_max = max(self.lin().value)\n    return 100 * abs(f_max - f_min) / sqrt(f_max * f_min)\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Frequency.to_time","title":"<code>to_time()</code>","text":"<p>Convert the frequency to equivalent period.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>def to_time(self):\n\"\"\"\n    Convert the frequency to equivalent period.\n    \"\"\"\n    if self.scale == \"lin\":\n        return Time(value=1 / self.value, scale=self.scale)\n    return Time(value=-self.value, scale=self.scale)\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Frequency.to_wavelength","title":"<code>to_wavelength(eps_r=1)</code>","text":"<p>Convert the frequency to the equivalent wavelength. eps_r : relative permittivity of the medium used.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>def to_wavelength(self, eps_r: float = 1):\n\"\"\"\n    Convert the frequency to the equivalent wavelength.\n    eps_r : relative permittivity of the medium used.\n    \"\"\"\n    f_lin = self.lin()\n    return PhysicalDimension(\n        value=sqrt(eps_r) * c0 / f_lin.value, scale=\"lin\", unit=\"m\"\n    )\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Time","title":"<code>Time</code>","text":"<p>         Bases: <code>PhysicalDimension</code></p> <p>Time class inherited from Physical Dimension.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>class Time(PhysicalDimension):\n\"\"\"\n    Time class inherited from Physical Dimension.\n    \"\"\"\n\n    unit = \"s\"\n\n    def __init__(self, value, scale=\"lin\", **data):\n        super().__init__(value=value, scale=scale, **data)\n\n    def to_freq(self):\n\"\"\"\n        Convert the period to equivalent frequency.\n        \"\"\"\n        if self.scale == \"lin\":\n            return Frequency(value=1 / self.value, scale=self.scale)\n        return Frequency(value=-self.value, scale=self.scale)\n</code></pre>"},{"location":"reference/passive_auto_design/units/time/#passive_auto_design.units.time.Time.to_freq","title":"<code>to_freq()</code>","text":"<p>Convert the period to equivalent frequency.</p> Source code in <code>passive_auto_design\\units\\time.py</code> <pre><code>def to_freq(self):\n\"\"\"\n    Convert the period to equivalent frequency.\n    \"\"\"\n    if self.scale == \"lin\":\n        return Frequency(value=1 / self.value, scale=self.scale)\n    return Frequency(value=-self.value, scale=self.scale)\n</code></pre>"},{"location":"reference/passive_auto_design/units/unit/","title":"unit","text":"<p>Some function to format physical dimensions.</p>"},{"location":"reference/passive_auto_design/units/unit/#passive_auto_design.units.unit.Impedance","title":"<code>Impedance(value)</code>","text":"<p>Format complex impedance to string with engineer format.</p> Source code in <code>passive_auto_design\\units\\unit.py</code> <pre><code>def Impedance(value):\n\"\"\"\n    Format complex impedance to string with engineer format.\n    \"\"\"\n    if imag(value) &lt; 0:\n        return __res(real(value)) + \" - j\" + __res(-imag(value)) + r\" $\\Omega$\"\n    return __res(real(value)) + \" + j\" + __res(imag(value)) + r\" $\\Omega$\"\n</code></pre>"}]}